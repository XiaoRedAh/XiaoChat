涉及的代码量太大了，因此只展示核心代码，重复较大的各种对象定义，crud等代码均不展示

# 登录功能

## 流程分析

step1：用户在窗体中发起登录事件，客户端向服务端发送登录请求
step2：服务端验证后，将验证结果以及初始化数据封装为登录响应，通过channel反馈给客户端。
step3：客户端依照服务端发来的验证结果，调用UI接口，执行登录成功或者提示登录失败操作。如果成功，还需将响应中的初始化数据展示到主界面上

## 协议定义

这部分编写的是chat-server-agreement模块，涉及protocol包下的内容：
```
protocol
│  Command.java
│  Packet.java
│
└─login
    │  LoginRequest.java
    │  LoginResponse.java
    │
    └─dto
            ChatRecordDto.java
            GroupsDto.java
            TalkBoxDto.java
            UserFriendDto.java
```
定义了登录请求和登录响应的协议格式，及它们需要在传输过程中负载的dto对象

***

登录请求 org/chat/server/protocol/login/LoginRequest.java
```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class LoginRequest extends Packet {
    private String userId;
    private String userPassword;
    
    @Override
    public Byte getCommand() {
        return Command.LoginRequest;
    }
}
```

登录响应 org/chat/server/protocol/login/LoginResponse.java
不仅包含了用户的基本信息，还有一些初始化数据；对话框、个人群组、个人好友
```java
/**
 * 登录响应协议：是否成功 + 用户基本信息 + 初始化数据（对话框，好友，群组）
 * @author XiaoRed
 * @date 2023/12/1 18:56
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class LoginResponse extends Packet {
    Boolean success; //登录成功为true
    private String userId; // 用户ID
    private String userNickName; //用户昵称
    private String userHead;  //用户头像
    private List<TalkBoxDto> chatTalkList = new ArrayList<>(); //聊天对话框数据
    private List<UserFriendDto> userFriendList = new ArrayList<>(); //加载好友列表
    private List<GroupsDto> groupsList = new ArrayList<>(); //加载群组列表

    @Override
    public Byte getCommand() {
        return Command.LoginResponse;
    }

    public boolean isSuccess() {
        return success;
    }
}
```

最后，往Command中，添加这两个协议的指令码
还要记得把协议和指令码的对应关系保存到Packet的map中

## UI登录事件实现

>在UI模块开发中，已经定义好了接口事件ILoginEvent，现在只需要在客户端做具体的功能实现即可，体现了架构设计时说到的UI与业务逻辑分离。

客户端获取socket通信管道channel，将登录请求发送到服务端
org/chat/client/event/LoginEvent.java
```java
/**
 * 实现UI登录事件
 * @author XiaoRed
 * @date 2023/11/30 18:48
 */
public class LoginEvent implements ILoginEvent {
    /**
     * 客户端将登录请求发送给服务端校验
     */
    @Override
    public void doLoginCheck(String userId, String userPassword) {
        Channel channel = BeanUtil.getBean("Channel");
        //客户端通过连接的信道，直接将登录请求发送给服务端校验
        channel.writeAndFlush(new LoginRequest(userId, userPassword));
        //todo：断线重连业务
    }
}
```
做断线重连功能时，要将用户ID一起发送给服务端，因此将来这里要搞个缓存，记录当前用户id

## 服务端处理登录请求

针对这个业务，用户领域的model添加如下对象
```
domain
├─inet
│  ├─model
│  ├─repository
│  └─service
└─user
    ├─model
    │      ChatRecordInfo.java
    │      GroupsInfo.java
    │      TalkBoxInfo.java
    │      UserFriendInfo.java
    │      UserGroupInfo.java
    │      UserInfo.java
    │
    ├─repository
    │      IUserRepository.java
    │
    └─service
            UserServiceImpl.java
```

处理登录的handler：org/chat/server/socket/handler/LoginHandler.java
* 指定LoginRequest泛型，该handler只会处理LoginRequest类型的数据
* 创建后，记得把它添加到pipeline中去

处理逻辑：
如果是验证用户身份信息不通过，则进行反馈：channel.writeAndFlush(new LoginResponse(false));
如果是验证用户身份信息通过
* 将用户ID与通信管道Channel的对应关系记录下来，为后续服务端实现通信功能做准备
* 基本数据的初始化，在登录后就可以看到群组、好友、对话、聊天记录等。【这里涉及对象转换和大量crud】

```java
/**
 * 登录业务处理
 * @author XiaoRed
 * @date 2023/12/1 23:38
 */
public class LoginHandler extends MyHandler<LoginRequest> {

    public LoginHandler(UserService userService){super(userService);}
    @Override
    public void channelRead(Channel channel, LoginRequest msg) {
        logger.info("正在处理登录请求：", JSON.toJSON(msg));
        boolean success = userService.checkAuth(msg.getUserId(), msg.getUserPassword());
        if(!success){ //登录校验不通过
            channel.writeAndFlush(new LoginResponse(false));
            return;
        }
        //登录校验通过
        //1. 将用户与channel的对应关系存储起来，方便后续服务端处理聊天业务
        SocketChannelUtil.addChannel(msg.getUserId(), channel);
        //2. 初始化数据：用户信息
        UserInfo userInfo = userService.queryUserInfo(msg.getUserId());
        //3. 初始化数据：好友列表
        List<UserFriendInfo> friendInfos = userService.queryUserFriendInfoList(msg.getUserId());
        //4. 初始化数据：群组列表
        List<GroupsInfo> groupsInfos = userService.queryGroupsInfoList(msg.getUserId());
        //5. 初始化数据：聊天框
        List<TalkBoxInfo> talkBoxInfos = userService.queryTalkBoxInfoList(msg.getUserId());
        //6. 封装LoginResponse对象
        LoginResponse loginResponse = new LoginResponse();
        ...
        ...加载各种初始化数据，一大堆的crud
        ...
        loginResponse.setSuccess(true);
        loginResponse.setUserId(userInfo.getUserId());
        loginResponse.setUserNickName(userInfo.getUserNickName());
        loginResponse.setUserHead(userInfo.getUserHead());
        //7. 通过channel向客户端响应LoginResponse
        channel.writeAndFlush(loginResponse);
    }
}
```

## 客户端处理登录响应

登录处理handler：org/chat/client/socket/handler/LoginHandler.java
* 指定LoginResponse泛型，该handler只会处理LoginResponse类型的数据
* 创建后，记得把它添加到pipeline中去

处理逻辑：
拿到响应后，先通过响应对象的isSuccess方法判断是否登录成功，如果不成功，打印登录失败，直接返回；
如果登录成功
* 通过UIService执行登录界面的成功事件（关闭），并将主界面chat展示
* 将响应对象里面携带的初始化数据展示到主界面chat中
```java
/**
 * 客户端处理登录响应
 * @author XiaoRed
 * @date 2023/12/2 8:31
 */
public class LoginHandler extends SimpleChannelInboundHandler<LoginResponse> {

    private UIService uiService;

    public LoginHandler(UIService uiService) {
        this.uiService = uiService;
    }

    @Override
    protected void channelRead0(ChannelHandlerContext ctx, LoginResponse msg) throws Exception {
        System.out.println("\r\n> msg handler ing ...");
        System.out.println("收到登录响应消息：" + JSON.toJSONString(msg));
        if (!msg.isSuccess()) {
            System.out.println("登录失败...");
            return;
        }
        //在非Fx线程中操作JavaFx线程相关任务时，需要在Platform.runLater中执行，但它不是线程阻塞型的，在javafx的主线程完全清空或者空闲的时候，才会执行
        Platform.runLater(() -> {
            uiService.getLogin().doLoginSuccess();
            IChatMethod chat = uiService.getChat();
            ...
            ...将登录响应中的初始化数据展示到chat界面
            ...
            }
        );
    }
}
```

# 搜索&添加好友

## 流程分析

为了方便，添加好友采取单方面同意，即用户A添加用户B为好友，不需要等B同意或不同意，就可以直接成为好友，立刻就能在好友列表中看到B，而用户B那里的好友列表，也立刻能看到用户A

step1：用户在窗体中发起添加/搜索事件，客户端向服务端发送添加/搜索请求
step2：服务端处理请求，通过channel反馈给客户端。
step3：客户端依照服务端发来的响应，调用UI接口，执行对应操作

## 协议定义

这部分编写的是chat-server-agreement模块，涉及protocol包下的内容
```
protocol
│  Command.java
│  Packet.java
│
├─friend
│  │  AddFriendRequest.java
│  │  AddFriendResponse.java
│  │  SearchFriendRequest.java
│  │  SearchFriendResponse.java
│  │
│  └─dto
│          UserDto.java
│
└─login略
```


搜索好友请求 org/chat/server/protocol/friend/SearchFriendRequest.java
```java
/**
 * 搜索好友请求协议：发起方id + 搜索关键字
 * @author XiaoRed
 * @date 2023/12/2 23:33
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class SearchFriendRequest extends Packet {
    private String userId; // 用户ID
    private String searchKey; // 搜索字段

    @Override
    public Byte getCommand() {
        return Command.SearchFriendRequest;
    }
}
```

搜索好友响应 org/chat/server/protocol/friend/SearchFriendResponse.java
```java
/**
 * 搜索好友响应协议：匹配搜索关键字的所有用户
 * @author XiaoRed
 * @date 2023/12/2 23:34
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class SearchFriendResponse extends Packet {

    private List<UserDto> list;

    @Override
    public Byte getCommand() {
        return Command.SearchFriendResponse;
    }
}
```

添加好友请求 org/chat/server/protocol/friend/AddFriendRequest.java
```java
/**
 * 添加好友请求协议：发起方id + 目标好友id
 * @author XiaoRed
 * @date 2023/12/2 23:33
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class AddFriendRequest extends Packet {

    private String userId; //用户ID[自己的ID]
    private String friendId; //目标好友ID

    @Override
    public Byte getCommand() {
        return Command.AddFriendRequest;
    }
}
```

添加好友响应 org/chat/server/protocol/friend/AddFriendResponse.java
```java
/**
 * 添加好友响应协议：好友id + 好友昵称 + 好友头像
 * @author XiaoRed
 * @date 2023/12/2 23:33
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class AddFriendResponse extends Packet {

    private String friendId;
    private String friendNickName;
    private String friendHead;

    @Override
    public Byte getCommand() {
        return Command.AddFriendResponse;
    }
}
```

最后，记得往Command中添加这四个协议对应的指令码
还要记得把协议和指令码的对应关系保存到Packet的map中

## UI事件实现

客户端获取socket通信管道channel，将请求发送到服务端

org/chat/client/event/ChatEvent.java
```java
    /**
     * 打开“新的朋友”窗体时触发，将发送方和空关键字封装为SearchFriendRequest，通过channel发送给服务端
     */
    @Override
    public void addFriendLuck(String userId, ListView<Pane> listView) {
        Channel channel = BeanUtil.getBean("Channel", Channel.class);
        channel.writeAndFlush(new SearchFriendRequest(userId, ""));
    }

    /**
     * 搜索好友时触发，将发送方和搜索关键字封装为SearchFriendRequest，通过channel发送给服务端
     */
    @Override
    public void doFriendLuckSearch(String userId, String text) {
        Channel channel = BeanUtil.getBean("Channel", Channel.class);
        channel.writeAndFlush(new SearchFriendRequest(userId, text));
    }

    /**
     * 点击“添加好友”时触发，将发送方id和目标添加id封装为AddFriendRequest，通过channel发送给服务端
     */
    @Override
    public void doEventAddLuckUser(String userId, String friendId) {
        Channel channel = BeanUtil.getBean("Channel", Channel.class);
        channel.writeAndFlush(new AddFriendRequest(userId, friendId));
    }
```

## 服务端处理请求

处理添加好友请求 org/chat/server/socket/handler/AddFriendHandler.java
处理逻辑
* 好友记录入库，双向的，一次入两条
* 向添加请求发起方推送响应，让发起方更新好友列表
* 向目标添加好友推送响应，让目标方更新好友列表
```java
/**
 * 服务端处理添加好友请求
 * @author XiaoRed
 * @date 2023/12/3 0:12
 */
public class AddFriendHandler extends MyHandler<AddFriendRequest> {

    public AddFriendHandler(UserService userService) {
        super(userService);
    }

    @Override
    public void channelRead(Channel channel, AddFriendRequest msg) {
      logger.info("处理添加好友请求：{}", JSON.toJSONString(msg));
        //不用管另一方同不同意，直接加为好友即可
        //1. 好友记录入库，双向的：(发起方，目标方)，(目标方，发起方)
        List<UserFriend> userFriendList = new ArrayList<>();
        userFriendList.add(new UserFriend(msg.getUserId(), msg.getFriendId()));
        userFriendList.add(new UserFriend(msg.getFriendId(), msg.getUserId()));
        userService.addUserFriend(userFriendList);
        //2. 通过channel，向发起方推送添加好友响应
        UserInfo userInfo = userService.queryUserInfo(msg.getFriendId());
        channel.writeAndFlush(new AddFriendResponse(userInfo.getUserId(), userInfo.getUserNickName(), userInfo.getUserHead()));
        //3. 通过channel，向目标方推送添加好友响应
        Channel friendChannel = SocketChannelUtil.getChannel(msg.getFriendId()); //先拿到目标方的channel
        if (null == friendChannel) return;
        UserInfo friendInfo = userService.queryUserInfo(msg.getUserId());
        friendChannel.writeAndFlush(new AddFriendResponse(friendInfo.getUserId(), friendInfo.getUserNickName(), friendInfo.getUserHead()));
    }
}
```

处理搜索好友请求 org/chat/server/socket/handler/SearchFriendHandler.java
模糊匹配 + 限制10条记录
```java
/**
 * 服务端处理搜索好友请求
 * @author XiaoRed
 * @date 2023/12/3 0:13
 */
public class SearchFriendHandler extends MyHandler<SearchFriendRequest> {

    public SearchFriendHandler(UserService userService) {
        super(userService);
    }

    @Override
    public void channelRead(Channel channel, SearchFriendRequest msg) {
        logger.info("处理搜索好友请求：{}", JSON.toJSONString(msg));
        //1. 根据关键字，模糊搜索出对应用户列表
        List<UserDto> userDtoList = new ArrayList<>();
        List<LuckUserInfo> userInfoList = userService.queryFuzzyUserInfoList(msg.getUserId(), msg.getSearchKey());
        //2. 转换为response里面要求的dto对象
        for (LuckUserInfo userInfo : userInfoList) {
            UserDto userDto = new UserDto();
            userDto.setUserId(userInfo.getUserId());
            userDto.setUserNickName(userInfo.getUserNickName());
            userDto.setUserHead(userInfo.getUserHead());
            userDto.setStatus(userInfo.getStatus());
            userDtoList.add(userDto);
        }
        //3. 将UserDto列表封装为response，通过channel推送给客户端
        SearchFriendResponse response = new SearchFriendResponse();
        response.setList(userDtoList);
        channel.writeAndFlush(response);
    }

}
```

最后记得往pipeline里添加上这两个handler

## 客户端处理响应

处理添加好友响应 org/chat/client/socket/handler/AddFriendHandler.java
拿到响应中，新好友的信息，添加到好友列表展示
```java
/**
 * 客户端处理添加好友响应
 * @author XiaoRed
 * @date 2023/12/3 0:01
 */
public class AddFriendHandler extends MyHandler<AddFriendResponse> {

    public AddFriendHandler(UIService uiService) {
        super(uiService);
    }

    @Override
    public void channelRead(Channel channel, AddFriendResponse msg) {
        IChatMethod chat = uiService.getChat();
        //在非Fx线程中操作JavaFx线程相关任务时，需要在Platform.runLater中执行，但它不是线程阻塞型的，在javafx的主线程完全清空或者空闲的时候，才会执行
        Platform.runLater(() -> {
            //将新好友展示到好友列表中
            chat.addFriendUser(true, msg.getFriendId(), msg.getFriendNickName(), msg.getFriendHead());
        });
    }

}
```

处理搜索好友响应 org/chat/client/socket/handler/SearchFriendHandler.java
拿到响应中，搜索到的用户列表，展示到UI界面
```java
/**
 * 客户端处理搜索好友响应
 * @author XiaoRed
 * @date 2023/12/3 0:01
 */
public class SearchFriendHandler extends SimpleChannelInboundHandler<SearchFriendResponse> {

    private UIService uiService;

    public SearchFriendHandler(UIService uiService) {
        this.uiService = uiService;
    }

    @Override
    protected void channelRead0(ChannelHandlerContext ctx, SearchFriendResponse msg) throws Exception {
        List<UserDto> list = msg.getList();
        if (null == list || list.isEmpty()) return;
        IChatMethod chat = uiService.getChat();
        //在非Fx线程中操作JavaFx线程相关任务时，需要在Platform.runLater中执行，但它不是线程阻塞型的，在javafx的主线程完全清空或者空闲的时候，才会执行
        Platform.runLater(() -> {
            //展示搜索结果
            for (UserDto user : list) {
                chat.addLuckFriend(user.getUserId(), user.getUserNickName(), user.getUserHead(), user.getStatus());
            }
        });
    }

}
```

最后记得往pipeline里添加上这两个handler
