涉及的代码量太大了，因此只展示核心代码，重复较大的各种对象定义，crud等代码均不展示

# 登录功能

## 流程分析

step1：用户在窗体中发起登录事件，客户端向服务端发送登录请求
step2：服务端验证后，将验证结果以及初始化数据封装为登录响应，通过channel反馈给客户端。
step3：客户端依照服务端发来的验证结果，调用UI接口，执行登录成功或者提示登录失败操作。如果成功，还需将响应中的初始化数据展示到主界面上

## 协议定义

这部分编写的是chat-server-agreement模块，涉及protocol包下的内容：
```
protocol
│  Command.java
│  Packet.java
│
└─login
    │  LoginRequest.java
    │  LoginResponse.java
    │
    └─dto
            ChatRecordDto.java
            GroupsDto.java
            TalkBoxDto.java
            UserFriendDto.java
```
定义了登录请求和登录响应的协议格式，及它们需要在传输过程中负载的dto对象

***

登录请求 org/chat/server/protocol/login/LoginRequest.java
```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class LoginRequest extends Packet {
    private String userId;
    private String userPassword;
    
    @Override
    public Byte getCommand() {
        return Command.LoginRequest;
    }
}
```

登录响应 org/chat/server/protocol/login/LoginResponse.java
不仅包含了用户的基本信息，还有一些初始化数据；对话框、个人群组、个人好友
```java
/**
 * 登录响应协议：是否成功 + 用户基本信息 + 初始化数据（对话框，好友，群组）
 * @author XiaoRed
 * @date 2023/12/1 18:56
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class LoginResponse extends Packet {
    Boolean success; //登录成功为true
    private String userId; // 用户ID
    private String userNickName; //用户昵称
    private String userHead;  //用户头像
    private List<TalkBoxDto> chatTalkList = new ArrayList<>(); //聊天对话框数据
    private List<UserFriendDto> userFriendList = new ArrayList<>(); //加载好友列表
    private List<GroupsDto> groupsList = new ArrayList<>(); //加载群组列表

    @Override
    public Byte getCommand() {
        return Command.LoginResponse;
    }

    public boolean isSuccess() {
        return success;
    }
}
```

最后，往Command中，添加这两个协议的指令码
还要记得把协议和指令码的对应关系保存到Packet的map中

## UI登录事件实现

>在UI模块开发中，已经定义好了接口事件ILoginEvent，现在只需要在客户端做具体的功能实现即可，体现了架构设计时说到的UI与业务逻辑分离。

客户端获取socket通信管道channel，将登录请求发送到服务端
org/chat/client/event/LoginEvent.java
```java
/**
 * 实现UI登录事件
 * @author XiaoRed
 * @date 2023/11/30 18:48
 */
public class LoginEvent implements ILoginEvent {
    /**
     * 客户端将登录请求发送给服务端校验
     */
    @Override
    public void doLoginCheck(String userId, String userPassword) {
        Channel channel = BeanUtil.getBean("Channel");
        //客户端通过连接的信道，直接将登录请求发送给服务端校验
        channel.writeAndFlush(new LoginRequest(userId, userPassword));
        //todo：断线重连业务
    }
}
```
做断线重连功能时，要将用户ID一起发送给服务端，因此将来这里要搞个缓存，记录当前用户id

## 服务端处理登录请求

针对这个业务，用户领域的model添加如下对象
```
domain
├─inet
│  ├─model
│  ├─repository
│  └─service
└─user
    ├─model
    │      ChatRecordInfo.java
    │      GroupsInfo.java
    │      TalkBoxInfo.java
    │      UserFriendInfo.java
    │      UserGroupInfo.java
    │      UserInfo.java
    │
    ├─repository
    │      IUserRepository.java
    │
    └─service
            UserServiceImpl.java
```

处理登录的handler：org/chat/server/socket/handler/LoginHandler.java
* 指定LoginRequest泛型，该handler只会处理LoginRequest类型的数据
* 创建后，记得把它添加到pipeline中去

处理逻辑：
如果是验证用户身份信息不通过，则进行反馈：channel.writeAndFlush(new LoginResponse(false));
如果是验证用户身份信息通过
* 将用户ID与通信管道Channel的对应关系记录下来，为后续服务端实现通信功能做准备
* 基本数据的初始化，在登录后就可以看到群组、好友、对话、聊天记录等。【这里涉及对象转换和大量crud】

```java
/**
 * 登录业务处理
 * @author XiaoRed
 * @date 2023/12/1 23:38
 */
public class LoginHandler extends MyHandler<LoginRequest> {

    public LoginHandler(UserService userService){super(userService);}
    @Override
    public void channelRead(Channel channel, LoginRequest msg) {
        logger.info("正在处理登录请求：", JSON.toJSON(msg));
        boolean success = userService.checkAuth(msg.getUserId(), msg.getUserPassword());
        if(!success){ //登录校验不通过
            channel.writeAndFlush(new LoginResponse(false));
            return;
        }
        //登录校验通过
        //1. 将用户与channel的对应关系存储起来，方便后续服务端处理聊天业务
        SocketChannelUtil.addChannel(msg.getUserId(), channel);
        //2. 初始化数据：用户信息
        UserInfo userInfo = userService.queryUserInfo(msg.getUserId());
        //3. 初始化数据：好友列表
        List<UserFriendInfo> friendInfos = userService.queryUserFriendInfoList(msg.getUserId());
        //4. 初始化数据：群组列表
        List<GroupsInfo> groupsInfos = userService.queryGroupsInfoList(msg.getUserId());
        //5. 初始化数据：聊天框
        List<TalkBoxInfo> talkBoxInfos = userService.queryTalkBoxInfoList(msg.getUserId());
        //6. 封装LoginResponse对象
        LoginResponse loginResponse = new LoginResponse();
        ...
        ...加载各种初始化数据，一大堆的crud
        ...
        loginResponse.setSuccess(true);
        loginResponse.setUserId(userInfo.getUserId());
        loginResponse.setUserNickName(userInfo.getUserNickName());
        loginResponse.setUserHead(userInfo.getUserHead());
        //7. 通过channel向客户端响应LoginResponse
        channel.writeAndFlush(loginResponse);
    }
}
```

## 客户端处理登录响应

登录处理handler：org/chat/client/socket/handler/LoginHandler.java
* 指定LoginResponse泛型，该handler只会处理LoginResponse类型的数据
* 创建后，记得把它添加到pipeline中去

处理逻辑：
拿到响应后，先通过响应对象的isSuccess方法判断是否登录成功，如果不成功，打印登录失败，直接返回；
如果登录成功
* 通过UIService执行登录界面的成功事件（关闭），并将主界面chat展示
* 将响应对象里面携带的初始化数据展示到主界面chat中
```java
/**
 * 客户端处理登录响应
 * @author XiaoRed
 * @date 2023/12/2 8:31
 */
public class LoginHandler extends SimpleChannelInboundHandler<LoginResponse> {

    private UIService uiService;

    public LoginHandler(UIService uiService) {
        this.uiService = uiService;
    }

    @Override
    protected void channelRead0(ChannelHandlerContext ctx, LoginResponse msg) throws Exception {
        System.out.println("\r\n> msg handler ing ...");
        System.out.println("收到登录响应消息：" + JSON.toJSONString(msg));
        if (!msg.isSuccess()) {
            System.out.println("登录失败...");
            return;
        }
        //在非Fx线程中操作JavaFx线程相关任务时，需要在Platform.runLater中执行，但它不是线程阻塞型的，在javafx的主线程完全清空或者空闲的时候，才会执行
        Platform.runLater(() -> {
            uiService.getLogin().doLoginSuccess();
            IChatMethod chat = uiService.getChat();
            ...
            ...将登录响应中的初始化数据展示到chat界面
            ...
            }
        );
    }
}
```

# 搜索&添加好友

## 流程分析

为了方便，添加好友采取单方面同意，即用户A添加用户B为好友，不需要等B同意或不同意，就可以直接成为好友，立刻就能在好友列表中看到B，而用户B那里的好友列表，也立刻能看到用户A

step1：用户在窗体中发起添加/搜索事件，客户端向服务端发送添加/搜索请求
step2：服务端处理请求，通过channel反馈给客户端。
step3：客户端依照服务端发来的响应，调用UI接口，执行对应操作

## 协议定义

这部分编写的是chat-server-agreement模块，涉及protocol包下的内容
```
protocol
│  Command.java
│  Packet.java
│
├─friend
│  │  AddFriendRequest.java
│  │  AddFriendResponse.java
│  │  SearchFriendRequest.java
│  │  SearchFriendResponse.java
│  │
│  └─dto
│          UserDto.java
│
└─login略
```


搜索好友请求 org/chat/server/protocol/friend/SearchFriendRequest.java
```java
/**
 * 搜索好友请求协议：发起方id + 搜索关键字
 * @author XiaoRed
 * @date 2023/12/2 23:33
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class SearchFriendRequest extends Packet {
    private String userId; // 用户ID
    private String searchKey; // 搜索字段

    @Override
    public Byte getCommand() {
        return Command.SearchFriendRequest;
    }
}
```

搜索好友响应 org/chat/server/protocol/friend/SearchFriendResponse.java
```java
/**
 * 搜索好友响应协议：匹配搜索关键字的所有用户
 * @author XiaoRed
 * @date 2023/12/2 23:34
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class SearchFriendResponse extends Packet {

    private List<UserDto> list;

    @Override
    public Byte getCommand() {
        return Command.SearchFriendResponse;
    }
}
```

添加好友请求 org/chat/server/protocol/friend/AddFriendRequest.java
```java
/**
 * 添加好友请求协议：发起方id + 目标好友id
 * @author XiaoRed
 * @date 2023/12/2 23:33
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class AddFriendRequest extends Packet {

    private String userId; //用户ID[自己的ID]
    private String friendId; //目标好友ID

    @Override
    public Byte getCommand() {
        return Command.AddFriendRequest;
    }
}
```

添加好友响应 org/chat/server/protocol/friend/AddFriendResponse.java
```java
/**
 * 添加好友响应协议：好友id + 好友昵称 + 好友头像
 * @author XiaoRed
 * @date 2023/12/2 23:33
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class AddFriendResponse extends Packet {

    private String friendId;
    private String friendNickName;
    private String friendHead;

    @Override
    public Byte getCommand() {
        return Command.AddFriendResponse;
    }
}
```

最后，记得往Command中添加这四个协议对应的指令码
还要记得把协议和指令码的对应关系保存到Packet的map中

## UI事件实现

客户端获取socket通信管道channel，将请求发送到服务端

org/chat/client/event/ChatEvent.java
```java
    /**
     * 打开“新的朋友”窗体时触发，将发送方和空关键字封装为SearchFriendRequest，通过channel发送给服务端
     */
    @Override
    public void addFriendLuck(String userId, ListView<Pane> listView) {
        Channel channel = BeanUtil.getBean("Channel", Channel.class);
        channel.writeAndFlush(new SearchFriendRequest(userId, ""));
    }

    /**
     * 搜索好友时触发，将发送方和搜索关键字封装为SearchFriendRequest，通过channel发送给服务端
     */
    @Override
    public void doFriendLuckSearch(String userId, String text) {
        Channel channel = BeanUtil.getBean("Channel", Channel.class);
        channel.writeAndFlush(new SearchFriendRequest(userId, text));
    }

    /**
     * 点击“添加好友”时触发，将发送方id和目标添加id封装为AddFriendRequest，通过channel发送给服务端
     */
    @Override
    public void doEventAddLuckUser(String userId, String friendId) {
        Channel channel = BeanUtil.getBean("Channel", Channel.class);
        channel.writeAndFlush(new AddFriendRequest(userId, friendId));
    }
```

## 服务端处理请求

处理添加好友请求 org/chat/server/socket/handler/AddFriendHandler.java
处理逻辑
* 好友记录入库，双向的，一次入两条
* 向添加请求发起方推送响应，让发起方更新好友列表
* 向目标添加好友推送响应，让目标方更新好友列表
```java
/**
 * 服务端处理添加好友请求
 * @author XiaoRed
 * @date 2023/12/3 0:12
 */
public class AddFriendHandler extends MyHandler<AddFriendRequest> {

    public AddFriendHandler(UserService userService) {
        super(userService);
    }

    @Override
    public void channelRead(Channel channel, AddFriendRequest msg) {
      logger.info("处理添加好友请求：{}", JSON.toJSONString(msg));
        //不用管另一方同不同意，直接加为好友即可
        //1. 好友记录入库，双向的：(发起方，目标方)，(目标方，发起方)
        List<UserFriend> userFriendList = new ArrayList<>();
        userFriendList.add(new UserFriend(msg.getUserId(), msg.getFriendId()));
        userFriendList.add(new UserFriend(msg.getFriendId(), msg.getUserId()));
        userService.addUserFriend(userFriendList);
        //2. 通过channel，向发起方推送添加好友响应
        UserInfo userInfo = userService.queryUserInfo(msg.getFriendId());
        channel.writeAndFlush(new AddFriendResponse(userInfo.getUserId(), userInfo.getUserNickName(), userInfo.getUserHead()));
        //3. 通过channel，向目标方推送添加好友响应
        Channel friendChannel = SocketChannelUtil.getChannel(msg.getFriendId()); //先拿到目标方的channel
        if (null == friendChannel) return;
        UserInfo friendInfo = userService.queryUserInfo(msg.getUserId());
        friendChannel.writeAndFlush(new AddFriendResponse(friendInfo.getUserId(), friendInfo.getUserNickName(), friendInfo.getUserHead()));
    }
}
```

处理搜索好友请求 org/chat/server/socket/handler/SearchFriendHandler.java
模糊匹配 + 限制10条记录
```java
/**
 * 服务端处理搜索好友请求
 * @author XiaoRed
 * @date 2023/12/3 0:13
 */
public class SearchFriendHandler extends MyHandler<SearchFriendRequest> {

    public SearchFriendHandler(UserService userService) {
        super(userService);
    }

    @Override
    public void channelRead(Channel channel, SearchFriendRequest msg) {
        logger.info("处理搜索好友请求：{}", JSON.toJSONString(msg));
        //1. 根据关键字，模糊搜索出对应用户列表
        List<UserDto> userDtoList = new ArrayList<>();
        List<LuckUserInfo> userInfoList = userService.queryFuzzyUserInfoList(msg.getUserId(), msg.getSearchKey());
        //2. 转换为response里面要求的dto对象
        for (LuckUserInfo userInfo : userInfoList) {
            UserDto userDto = new UserDto();
            userDto.setUserId(userInfo.getUserId());
            userDto.setUserNickName(userInfo.getUserNickName());
            userDto.setUserHead(userInfo.getUserHead());
            userDto.setStatus(userInfo.getStatus());
            userDtoList.add(userDto);
        }
        //3. 将UserDto列表封装为response，通过channel推送给客户端
        SearchFriendResponse response = new SearchFriendResponse();
        response.setList(userDtoList);
        channel.writeAndFlush(response);
    }

}
```

最后记得往pipeline里添加上这两个handler

## 客户端处理响应

处理添加好友响应 org/chat/client/socket/handler/AddFriendHandler.java
拿到响应中，新好友的信息，添加到好友列表展示
```java
/**
 * 客户端处理添加好友响应
 * @author XiaoRed
 * @date 2023/12/3 0:01
 */
public class AddFriendHandler extends MyHandler<AddFriendResponse> {

    public AddFriendHandler(UIService uiService) {
        super(uiService);
    }

    @Override
    public void channelRead(Channel channel, AddFriendResponse msg) {
        IChatMethod chat = uiService.getChat();
        //在非Fx线程中操作JavaFx线程相关任务时，需要在Platform.runLater中执行，但它不是线程阻塞型的，在javafx的主线程完全清空或者空闲的时候，才会执行
        Platform.runLater(() -> {
            //将新好友展示到好友列表中
            chat.addFriendUser(true, msg.getFriendId(), msg.getFriendNickName(), msg.getFriendHead());
        });
    }

}
```

处理搜索好友响应 org/chat/client/socket/handler/SearchFriendHandler.java
拿到响应中，搜索到的用户列表，展示到UI界面
```java
/**
 * 客户端处理搜索好友响应
 * @author XiaoRed
 * @date 2023/12/3 0:01
 */
public class SearchFriendHandler extends SimpleChannelInboundHandler<SearchFriendResponse> {

    private UIService uiService;

    public SearchFriendHandler(UIService uiService) {
        this.uiService = uiService;
    }

    @Override
    protected void channelRead0(ChannelHandlerContext ctx, SearchFriendResponse msg) throws Exception {
        List<UserDto> list = msg.getList();
        if (null == list || list.isEmpty()) return;
        IChatMethod chat = uiService.getChat();
        //在非Fx线程中操作JavaFx线程相关任务时，需要在Platform.runLater中执行，但它不是线程阻塞型的，在javafx的主线程完全清空或者空闲的时候，才会执行
        Platform.runLater(() -> {
            //展示搜索结果
            for (UserDto user : list) {
                chat.addLuckFriend(user.getUserId(), user.getUserNickName(), user.getUserHead(), user.getStatus());
            }
        });
    }

}
```

最后记得往pipeline里添加上这两个handler

# 对话通知与应答

## 流程分析

**需求**
聊天的时候，页面左侧会展示一个对话框列表，它不是展示用户的好友/加入的群组，而是与谁对话了，才会展示该对话框

对话框获取数据的两种情况：
* 当你从好友/群组列表中选择一个好友/群组进行对话，点击“发送信息”的时候
* 当你收到一条来自好友/群组的消息的时候

**流程**
step1：用户发起好友、群组通信的时候，会触发一个事件行为，然后客户端向服务端发送对话请求。
step2：服务端收到对话请求后
* 如果是好友对话，创建两个对话框（发送方看到的，目标方看到的）并入库，然后通知好友，我与你要通信了，你在自己的对话框列表中，把我加进去（把刚入库的对话框加载到对话框列表）
* 如果是群组通信，不可能把还没有在线的所有群组用户全部通知，所以只需要创建对话框数据（目标方看到的那个）并入库，群组里的用户上线后，就能加载到这个对话框了。


## 协议定义

org/chat/server/protocol/talk/TalkNoticeRequest.java
对话通知请求协议：发起方id + 目标方id + 通讯类型（单聊or群聊）
```java
/**
 * 对话通知请求协议：发起方id + 目标方id + 通讯类型（单聊or群聊）
 * @author XiaoRed
 * @date 2023/12/8 20:57
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class TalkNoticeRequest extends Packet {

    private String userId; // 用户ID【发起方】
    private String friendUserId; // 目标方id【好友id或群组id，看是啥类型】
    private Integer talkType; // 对话框类型[0好友、1群组]

    @Override
    public Byte getCommand() {
        return Command.TalkNoticeRequest;
    }

}
```

org/chat/server/protocol/talk/TalkNoticeResponse.java
对话通知响应协议：对话框id + 展示该对话框需要的属性（名称，头像，简讯，时间）
```java
/**
 * 对话通知响应协议：对话框id + 展示该对话框需要的属性（名称，头像，简讯，时间）
 * @author XiaoRed
 * @date 2023/12/8 21:01
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class TalkNoticeResponse extends Packet {

    private String talkId;  // 对话框ID[好友ID、群ID]
    private String talkName; // 对话框名称[好友名称、群名称]
    private String talkHead; // 对话框头像[好友头像、群头像]
    private String talkSketch; // 消息简讯
    private Date talkDate; // 消息时间

    @Override
    public Byte getCommand() {
        return Command.TalkNoticeResponse;
    }
}
```

org/chat/server/protocol/talk/DelTalkRequest.java
删除对话框请求协议：发起方id + 要删除的对话框id
```java
/**
 * 删除对话框请求协议：发起方id + 要删除的对话框id
 * @author XiaoRed
 * @date 2023/12/8 21:03
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class DelTalkRequest extends Packet {

    private String userId; // 用户ID【谁要删对话框】
    private String talkId;  // 对话框ID【删哪个对话框】

    @Override
    public Byte getCommand() {
        return Command.DelTalkRequest;
    }

}
```

最后，记得往Command中添加这四个协议对应的指令码
还要记得把协议和指令码的对应关系保存到Packet的map中

## UI事件实现

客户端获取socket通信管道channel，将请求发送到服务端

org/chat/client/event/ChatEvent.java
```java
    /**
     * 对好友点击“发送消息”按钮时触发，向服务端发送对话通知请求
     */
    @Override
    public void doEventAddTalkUser(String userId, String userFriendId) {
        Channel channel = BeanUtil.getBean("Channel", Channel.class);
        channel.writeAndFlush(new TalkNoticeRequest(userId, userFriendId, 0));
    }

    /**
     * 对群组点击“发送消息”按钮时触发，向服务端发送对话通知请求
     */
    @Override
    public void doEventAddTalkGroup(String userId, String groupId) {
        Channel channel = BeanUtil.getBean("Channel", Channel.class);
        channel.writeAndFlush(new TalkNoticeRequest(userId, groupId, 1));
    }

    /**
     * 用户删除一个对话框时触发，向服务端发送删除对话框请求
     */
    @Override
    public void doEventDelTalkUser(String userId, String talkId) {
        Channel channel = BeanUtil.getBean("Channel", Channel.class);
        channel.writeAndFlush(new DelTalkRequest(userId, talkId));
    }
```

***
除此之外，ui工程还写好了两个方法，发起方会直接创建对应的对话框，并跳转到聊天界面
org/chat/ui/view/chat/ChatEventDefine.java
```java
    // 好友；开启与好友发送消息 [点击发送消息时候触发 -> 添加到对话框、选中、展示对话列表]
    public void doEventOpenFriendUserSendMsg(Button sendMsgButton, String userFriendId, String userFriendNickName, String userFriendHead) {
        sendMsgButton.setOnAction(event -> {
            // 1. 添加好友到对话框
            chatMethod.addTalkBox(0, 0, userFriendId, userFriendNickName, userFriendHead, null, null, true);
            // 2. 切换到对话框窗口
            switchBarChat(chatInit.$("bar_chat", Button.class), chatInit.$("group_bar_chat", Pane.class), true);
            switchBarFriend(chatInit.$("bar_friend", Button.class), chatInit.$("group_bar_friend", Pane.class), false);
            // 3. 事件处理；填充到对话框
            chatEvent.doEventAddTalkUser(chatInit.userId, userFriendId);
        });
    }

    // 群组；开启与群组发送消息
    public void doEventOpenFriendGroupSendMsg(Button sendMsgButton, String groupId, String groupName, String groupHead) {
        sendMsgButton.setOnAction(event -> {
            // 1. 添加好友到对话框
            chatMethod.addTalkBox(0, 1, groupId, groupName, groupHead, null, null, true);
            // 2. 切换到对话框窗口
            switchBarChat(chatInit.$("bar_chat", Button.class), chatInit.$("group_bar_chat", Pane.class), true);
            switchBarFriend(chatInit.$("bar_friend", Button.class), chatInit.$("group_bar_friend", Pane.class), false);
            // 3. 事件处理；填充到对话框
            chatEvent.doEventAddTalkGroup(chatInit.userId, groupId);
        });
    }
```

## 服务端处理请求

生成对话框相应的数据，入库
封装为对话框传输dto，封装到响应协议中
发送方，目标方都要发送响应包

依照不同的对话框类型`talkType = 0(用户)/1(群组)`，来做不同的处理：
* 好友对话请求：将对话框进行落库操作，发起方与目标方都进行落库。然后发送对话通知响应【目标方看到的对话框】给好友（目标方）
* 群组通信请求：只是进行落库，并且只落自己（发起方）和群组的通信。因为这个时候并不能把所有群友逐个通知并进行落库，从流程上看也不是合理的。

服务端处理对话通知请求
org/chat/server/socket/handler/TalkNoticeHandler.java
```java
/**
 * 服务端处理对话通知请求
 * @author XiaoRed
 * @date 2023/12/8 21:48
 */
public class TalkNoticeHandler extends MyHandler<TalkNoticeRequest> {

    public TalkNoticeHandler(UserService userService) {
        super(userService);
    }

    @Override
    public void channelRead(Channel channel, TalkNoticeRequest msg) {
        logger.info("对话通知应答处理：{}", JSON.toJSONString(msg));

        switch (msg.getTalkType()) {
            //好友对话请求【单聊】
            case 0:
                // 1. 对话框数据落库
                userService.addTalkBoxInfo(msg.getUserId(), msg.getFriendUserId(), 0);
                userService.addTalkBoxInfo(msg.getFriendUserId(), msg.getUserId(), 0);
                // 2. 查询发起方的用户信息[将发起方发给目标方的对话框中]
                UserInfo userInfo = userService.queryUserInfo(msg.getUserId());
                // 3. 发送对话框消息给好友
                TalkNoticeResponse response = new TalkNoticeResponse();
                response.setTalkId(userInfo.getUserId());
                response.setTalkName(userInfo.getUserNickName());
                response.setTalkHead(userInfo.getUserHead());
                response.setTalkSketch(null);
                response.setTalkDate(new Date());
                // 获取好友通信管道，好友处于登录状态，才把响应发送给好友
                Channel friendChannel = SocketChannelUtil.getChannel(msg.getFriendUserId());
                if (null == friendChannel) {
                    logger.info("用户id：{}未登录！", msg.getFriendUserId());
                    return;
                }
                friendChannel.writeAndFlush(response);
                break;
            //群组通讯请求【群聊】
            case 1:
                userService.addTalkBoxInfo(msg.getUserId(), msg.getFriendUserId(), 1);
                break;
            default:
                break;
        }
    }
}
```

***
除此之外，还有处理删除对话框请求的处理器，这个比较简单，直接从数据库删对应id的记录就行
```java
/**
 * 服务端处理删除对话框请求
 * @author XiaoRed
 * @date 2023/12/8 22:06
 */
public class DelTalkHandler extends MyHandler<DelTalkRequest> {

    public DelTalkHandler(UserService userService) {
        super(userService);
    }

    @Override
    public void channelRead(Channel channel, DelTalkRequest msg) {
        userService.deleteUserTalk(msg.getUserId(), msg.getTalkId());
    }
}
```

最后记得往pipeline里添加上这两个handler

## 客户端处理响应

客户端处理对话通知响应
org/chat/client/socket/handler/TalkNoticeHandler.java
向聊天界面中添加对应的对话框（通过加载响应中传来的数据）
```java
/**
 * 客户端处理对话通知响应：向聊天界面中添加对应的对话框（通过加载响应中传来的数据）
 * @author XiaoRed
 * @date 2023/12/8 21:24
 */
public class TalkNoticeHandler extends SimpleChannelInboundHandler<TalkNoticeResponse> {

    private UIService uiService;

    public TalkNoticeHandler(UIService uiService) {this.uiService = uiService;}

    @Override
    protected void channelRead0(ChannelHandlerContext channelHandlerContext, TalkNoticeResponse msg) throws Exception {
        IChatMethod chat = uiService.getChat();
        Platform.runLater(() -> {
            chat.addTalkBox(-1, 0, msg.getTalkId(), msg.getTalkName(), msg.getTalkHead(), msg.getTalkSketch(), msg.getTalkDate(), false);
        });
    }
}
```

最后记得往pipeline里添加上这个handler