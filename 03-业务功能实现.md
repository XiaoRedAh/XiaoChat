涉及的代码量太大了，因此只展示核心代码，重复较大的各种对象定义，crud等代码均不展示

# 登录功能

## 流程分析

step1：用户在窗体中发起登录事件，客户端向服务端发送登录请求
step2：服务端验证后，将验证结果以及初始化数据封装为登录响应，通过channel反馈给客户端。
step3：客户端依照服务端发来的验证结果，调用UI接口，执行登录成功或者提示登录失败操作。如果成功，还需将响应中的初始化数据展示到主界面上

## 协议定义

这部分编写的是chat-server-agreement模块，涉及protocol包下的内容：
```
protocol
│  Command.java
│  Packet.java
│
└─login
    │  LoginRequest.java
    │  LoginResponse.java
    │
    └─dto
            ChatRecordDto.java
            GroupsDto.java
            TalkBoxDto.java
            UserFriendDto.java
```
定义了登录请求和登录响应的协议格式，及它们需要在传输过程中负载的dto对象

***

登录请求 org/chat/server/protocol/login/LoginRequest.java
```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class LoginRequest extends Packet {
    private String userId;
    private String userPassword;
    
    @Override
    public Byte getCommand() {
        return Command.LoginRequest;
    }
}
```

登录响应 org/chat/server/protocol/login/LoginResponse.java
不仅包含了用户的基本信息，还有一些初始化数据；对话框、个人群组、个人好友
```java
/**
 * 登录响应协议：是否成功 + 用户基本信息 + 初始化数据（对话框，好友，群组）
 * @author XiaoRed
 * @date 2023/12/1 18:56
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class LoginResponse extends Packet {
    Boolean success; //登录成功为true
    private String userId; // 用户ID
    private String userNickName; //用户昵称
    private String userHead;  //用户头像
    private List<TalkBoxDto> chatTalkList = new ArrayList<>(); //聊天对话框数据
    private List<UserFriendDto> userFriendList = new ArrayList<>(); //加载好友列表
    private List<GroupsDto> groupsList = new ArrayList<>(); //加载群组列表

    @Override
    public Byte getCommand() {
        return Command.LoginResponse;
    }

    public boolean isSuccess() {
        return success;
    }
}
```

最后，往Command中，添加这两个协议的指令码
还要记得把协议和指令码的对应关系保存到Packet的map中

## UI登录事件实现

>在UI模块开发中，已经定义好了接口事件ILoginEvent，现在只需要在客户端做具体的功能实现即可，体现了架构设计时说到的UI与业务逻辑分离。

客户端获取socket通信管道channel，将登录请求发送到服务端
org/chat/client/event/LoginEvent.java
```java
/**
 * 实现UI登录事件
 * @author XiaoRed
 * @date 2023/11/30 18:48
 */
public class LoginEvent implements ILoginEvent {
    /**
     * 客户端将登录请求发送给服务端校验
     */
    @Override
    public void doLoginCheck(String userId, String userPassword) {
        Channel channel = BeanUtil.getBean("Channel");
        //客户端通过连接的信道，直接将登录请求发送给服务端校验
        channel.writeAndFlush(new LoginRequest(userId, userPassword));
        //todo：断线重连业务
    }
}
```
做断线重连功能时，要将用户ID一起发送给服务端，因此将来这里要搞个缓存，记录当前用户id

## 服务端处理登录请求

针对这个业务，用户领域的model添加如下对象
```
domain
├─inet
│  ├─model
│  ├─repository
│  └─service
└─user
    ├─model
    │      ChatRecordInfo.java
    │      GroupsInfo.java
    │      TalkBoxInfo.java
    │      UserFriendInfo.java
    │      UserGroupInfo.java
    │      UserInfo.java
    │
    ├─repository
    │      IUserRepository.java
    │
    └─service
            UserServiceImpl.java
```

处理登录的handler：org/chat/server/socket/handler/LoginHandler.java
* 指定LoginRequest泛型，该handler只会处理LoginRequest类型的数据
* 创建后，记得把它添加到pipeline中去

处理逻辑：
如果是验证用户身份信息不通过，则进行反馈：channel.writeAndFlush(new LoginResponse(false));
如果是验证用户身份信息通过
* 将用户ID与通信管道Channel的对应关系记录下来，为后续服务端实现通信功能做准备
* 基本数据的初始化，在登录后就可以看到群组、好友、对话、聊天记录等。【这里涉及对象转换和大量crud】

```java
/**
 * 登录业务处理
 * @author XiaoRed
 * @date 2023/12/1 23:38
 */
public class LoginHandler extends MyHandler<LoginRequest> {

    public LoginHandler(UserService userService){super(userService);}
    @Override
    public void channelRead(Channel channel, LoginRequest msg) {
        logger.info("正在处理登录请求：", JSON.toJSON(msg));
        boolean success = userService.checkAuth(msg.getUserId(), msg.getUserPassword());
        if(!success){ //登录校验不通过
            channel.writeAndFlush(new LoginResponse(false));
            return;
        }
        //登录校验通过
        //1. 将用户与channel的对应关系存储起来，方便后续服务端处理聊天业务
        SocketChannelUtil.addChannel(msg.getUserId(), channel);
        //2. 初始化数据：用户信息
        UserInfo userInfo = userService.queryUserInfo(msg.getUserId());
        //3. 初始化数据：好友列表
        List<UserFriendInfo> friendInfos = userService.queryUserFriendInfoList(msg.getUserId());
        //4. 初始化数据：群组列表
        List<GroupsInfo> groupsInfos = userService.queryGroupsInfoList(msg.getUserId());
        //5. 初始化数据：聊天框
        List<TalkBoxInfo> talkBoxInfos = userService.queryTalkBoxInfoList(msg.getUserId());
        //6. 封装LoginResponse对象
        LoginResponse loginResponse = new LoginResponse();
        ...
        ...加载各种初始化数据，一大堆的crud
        ...
        loginResponse.setSuccess(true);
        loginResponse.setUserId(userInfo.getUserId());
        loginResponse.setUserNickName(userInfo.getUserNickName());
        loginResponse.setUserHead(userInfo.getUserHead());
        //7. 通过channel向客户端响应LoginResponse
        channel.writeAndFlush(loginResponse);
    }
}
```

## 客户端处理登录响应

登录处理handler：org/chat/client/socket/handler/LoginHandler.java
* 指定LoginResponse泛型，该handler只会处理LoginResponse类型的数据
* 创建后，记得把它添加到pipeline中去

处理逻辑：
拿到响应后，先通过响应对象的isSuccess方法判断是否登录成功，如果不成功，打印登录失败，直接返回；
如果登录成功
* 通过UIService执行登录界面的成功事件（关闭），并将主界面chat展示
* 将响应对象里面携带的初始化数据展示到主界面chat中
```java
/**
 * 客户端处理登录响应
 * @author XiaoRed
 * @date 2023/12/2 8:31
 */
public class LoginHandler extends SimpleChannelInboundHandler<LoginResponse> {

    private UIService uiService;

    public LoginHandler(UIService uiService) {
        this.uiService = uiService;
    }

    @Override
    protected void channelRead0(ChannelHandlerContext ctx, LoginResponse msg) throws Exception {
        System.out.println("\r\n> msg handler ing ...");
        System.out.println("收到登录响应消息：" + JSON.toJSONString(msg));
        if (!msg.isSuccess()) {
            System.out.println("登录失败...");
            return;
        }
        //在非Fx线程中操作JavaFx线程相关任务时，需要在Platform.runLater中执行，但它不是线程阻塞型的，在javafx的主线程完全清空或者空闲的时候，才会执行
        Platform.runLater(() -> {
            uiService.getLogin().doLoginSuccess();
            IChatMethod chat = uiService.getChat();
            ...
            ...将登录响应中的初始化数据展示到chat界面
            ...
            }
        );
    }
}
```

# 搜索&添加好友

## 流程分析

为了方便，添加好友采取单方面同意，即用户A添加用户B为好友，不需要等B同意或不同意，就可以直接成为好友，立刻就能在好友列表中看到B，而用户B那里的好友列表，也立刻能看到用户A

step1：用户在窗体中发起添加/搜索事件，客户端向服务端发送添加/搜索请求
step2：服务端处理请求，通过channel反馈给客户端。
step3：客户端依照服务端发来的响应，调用UI接口，执行对应操作

## 协议定义

这部分编写的是chat-server-agreement模块，涉及protocol包下的内容
```
protocol
│  Command.java
│  Packet.java
│
├─friend
│  │  AddFriendRequest.java
│  │  AddFriendResponse.java
│  │  SearchFriendRequest.java
│  │  SearchFriendResponse.java
│  │
│  └─dto
│          UserDto.java
│
└─login略
```


搜索好友请求 org/chat/server/protocol/friend/SearchFriendRequest.java
```java
/**
 * 搜索好友请求协议：发起方id + 搜索关键字
 * @author XiaoRed
 * @date 2023/12/2 23:33
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class SearchFriendRequest extends Packet {
    private String userId; // 用户ID
    private String searchKey; // 搜索字段

    @Override
    public Byte getCommand() {
        return Command.SearchFriendRequest;
    }
}
```

搜索好友响应 org/chat/server/protocol/friend/SearchFriendResponse.java
```java
/**
 * 搜索好友响应协议：匹配搜索关键字的所有用户
 * @author XiaoRed
 * @date 2023/12/2 23:34
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class SearchFriendResponse extends Packet {

    private List<UserDto> list;

    @Override
    public Byte getCommand() {
        return Command.SearchFriendResponse;
    }
}
```

添加好友请求 org/chat/server/protocol/friend/AddFriendRequest.java
```java
/**
 * 添加好友请求协议：发起方id + 目标好友id
 * @author XiaoRed
 * @date 2023/12/2 23:33
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class AddFriendRequest extends Packet {

    private String userId; //用户ID[自己的ID]
    private String friendId; //目标好友ID

    @Override
    public Byte getCommand() {
        return Command.AddFriendRequest;
    }
}
```

添加好友响应 org/chat/server/protocol/friend/AddFriendResponse.java
```java
/**
 * 添加好友响应协议：好友id + 好友昵称 + 好友头像
 * @author XiaoRed
 * @date 2023/12/2 23:33
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class AddFriendResponse extends Packet {

    private String friendId;
    private String friendNickName;
    private String friendHead;

    @Override
    public Byte getCommand() {
        return Command.AddFriendResponse;
    }
}
```

最后，记得往Command中添加这四个协议对应的指令码
还要记得把协议和指令码的对应关系保存到Packet的map中

## UI事件实现

客户端获取socket通信管道channel，将请求发送到服务端

org/chat/client/event/ChatEvent.java
```java
    /**
     * 打开“新的朋友”窗体时触发，将发送方和空关键字封装为SearchFriendRequest，通过channel发送给服务端
     */
    @Override
    public void addFriendLuck(String userId, ListView<Pane> listView) {
        Channel channel = BeanUtil.getBean("Channel", Channel.class);
        channel.writeAndFlush(new SearchFriendRequest(userId, ""));
    }

    /**
     * 搜索好友时触发，将发送方和搜索关键字封装为SearchFriendRequest，通过channel发送给服务端
     */
    @Override
    public void doFriendLuckSearch(String userId, String text) {
        Channel channel = BeanUtil.getBean("Channel", Channel.class);
        channel.writeAndFlush(new SearchFriendRequest(userId, text));
    }

    /**
     * 点击“添加好友”时触发，将发送方id和目标添加id封装为AddFriendRequest，通过channel发送给服务端
     */
    @Override
    public void doEventAddLuckUser(String userId, String friendId) {
        Channel channel = BeanUtil.getBean("Channel", Channel.class);
        channel.writeAndFlush(new AddFriendRequest(userId, friendId));
    }
```

## 服务端处理请求

处理添加好友请求 org/chat/server/socket/handler/AddFriendHandler.java
处理逻辑
* 好友记录入库，双向的，一次入两条
* 向添加请求发起方推送响应，让发起方更新好友列表
* 向目标添加好友推送响应，让目标方更新好友列表
```java
/**
 * 服务端处理添加好友请求
 * @author XiaoRed
 * @date 2023/12/3 0:12
 */
public class AddFriendHandler extends MyHandler<AddFriendRequest> {

    public AddFriendHandler(UserService userService) {
        super(userService);
    }

    @Override
    public void channelRead(Channel channel, AddFriendRequest msg) {
      logger.info("处理添加好友请求：{}", JSON.toJSONString(msg));
        //不用管另一方同不同意，直接加为好友即可
        //1. 好友记录入库，双向的：(发起方，目标方)，(目标方，发起方)
        List<UserFriend> userFriendList = new ArrayList<>();
        userFriendList.add(new UserFriend(msg.getUserId(), msg.getFriendId()));
        userFriendList.add(new UserFriend(msg.getFriendId(), msg.getUserId()));
        userService.addUserFriend(userFriendList);
        //2. 通过channel，向发起方推送添加好友响应
        UserInfo userInfo = userService.queryUserInfo(msg.getFriendId());
        channel.writeAndFlush(new AddFriendResponse(userInfo.getUserId(), userInfo.getUserNickName(), userInfo.getUserHead()));
        //3. 通过channel，向目标方推送添加好友响应
        Channel friendChannel = SocketChannelUtil.getChannel(msg.getFriendId()); //先拿到目标方的channel
        if (null == friendChannel) return;
        UserInfo friendInfo = userService.queryUserInfo(msg.getUserId());
        friendChannel.writeAndFlush(new AddFriendResponse(friendInfo.getUserId(), friendInfo.getUserNickName(), friendInfo.getUserHead()));
    }
}
```

处理搜索好友请求 org/chat/server/socket/handler/SearchFriendHandler.java
模糊匹配 + 限制10条记录
```java
/**
 * 服务端处理搜索好友请求
 * @author XiaoRed
 * @date 2023/12/3 0:13
 */
public class SearchFriendHandler extends MyHandler<SearchFriendRequest> {

    public SearchFriendHandler(UserService userService) {
        super(userService);
    }

    @Override
    public void channelRead(Channel channel, SearchFriendRequest msg) {
        logger.info("处理搜索好友请求：{}", JSON.toJSONString(msg));
        //1. 根据关键字，模糊搜索出对应用户列表
        List<UserDto> userDtoList = new ArrayList<>();
        List<LuckUserInfo> userInfoList = userService.queryFuzzyUserInfoList(msg.getUserId(), msg.getSearchKey());
        //2. 转换为response里面要求的dto对象
        for (LuckUserInfo userInfo : userInfoList) {
            UserDto userDto = new UserDto();
            userDto.setUserId(userInfo.getUserId());
            userDto.setUserNickName(userInfo.getUserNickName());
            userDto.setUserHead(userInfo.getUserHead());
            userDto.setStatus(userInfo.getStatus());
            userDtoList.add(userDto);
        }
        //3. 将UserDto列表封装为response，通过channel推送给客户端
        SearchFriendResponse response = new SearchFriendResponse();
        response.setList(userDtoList);
        channel.writeAndFlush(response);
    }

}
```

最后记得往pipeline里添加上这两个handler

## 客户端处理响应

处理添加好友响应 org/chat/client/socket/handler/AddFriendHandler.java
拿到响应中，新好友的信息，添加到好友列表展示
```java
/**
 * 客户端处理添加好友响应
 * @author XiaoRed
 * @date 2023/12/3 0:01
 */
public class AddFriendHandler extends MyHandler<AddFriendResponse> {

    public AddFriendHandler(UIService uiService) {
        super(uiService);
    }

    @Override
    public void channelRead(Channel channel, AddFriendResponse msg) {
        IChatMethod chat = uiService.getChat();
        //在非Fx线程中操作JavaFx线程相关任务时，需要在Platform.runLater中执行，但它不是线程阻塞型的，在javafx的主线程完全清空或者空闲的时候，才会执行
        Platform.runLater(() -> {
            //将新好友展示到好友列表中
            chat.addFriendUser(true, msg.getFriendId(), msg.getFriendNickName(), msg.getFriendHead());
        });
    }

}
```

处理搜索好友响应 org/chat/client/socket/handler/SearchFriendHandler.java
拿到响应中，搜索到的用户列表，展示到UI界面
```java
/**
 * 客户端处理搜索好友响应
 * @author XiaoRed
 * @date 2023/12/3 0:01
 */
public class SearchFriendHandler extends SimpleChannelInboundHandler<SearchFriendResponse> {

    private UIService uiService;

    public SearchFriendHandler(UIService uiService) {
        this.uiService = uiService;
    }

    @Override
    protected void channelRead0(ChannelHandlerContext ctx, SearchFriendResponse msg) throws Exception {
        List<UserDto> list = msg.getList();
        if (null == list || list.isEmpty()) return;
        IChatMethod chat = uiService.getChat();
        //在非Fx线程中操作JavaFx线程相关任务时，需要在Platform.runLater中执行，但它不是线程阻塞型的，在javafx的主线程完全清空或者空闲的时候，才会执行
        Platform.runLater(() -> {
            //展示搜索结果
            for (UserDto user : list) {
                chat.addLuckFriend(user.getUserId(), user.getUserNickName(), user.getUserHead(), user.getStatus());
            }
        });
    }

}
```

最后记得往pipeline里添加上这两个handler

# 对话通知与应答

## 流程分析

**需求**
聊天的时候，页面左侧会展示一个对话框列表，它不是展示用户的好友/加入的群组，而是与谁对话了，才会展示该对话框

对话框获取数据的两种情况：
* 当你从好友/群组列表中选择一个好友/群组进行对话，点击“发送信息”的时候
* 当你收到一条来自好友/群组的消息的时候

**流程**
step1：用户发起好友、群组通信的时候，会触发一个事件行为，然后客户端向服务端发送对话请求。
step2：服务端收到对话请求后
* 如果是好友对话，创建两个对话框（发送方看到的，目标方看到的）并入库，然后通知好友，我与你要通信了，你在自己的对话框列表中，把我加进去（把刚入库的对话框加载到对话框列表）
* 如果是群组通信，不可能把还没有在线的所有群组用户全部通知，所以只需要创建对话框数据（目标方看到的那个）并入库，群组里的用户上线后，就能加载到这个对话框了。


## 协议定义

org/chat/server/protocol/talk/TalkNoticeRequest.java
对话通知请求协议：发起方id + 目标方id + 通讯类型（单聊or群聊）
```java
/**
 * 对话通知请求协议：发起方id + 目标方id + 通讯类型（单聊or群聊）
 * @author XiaoRed
 * @date 2023/12/8 20:57
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class TalkNoticeRequest extends Packet {

    private String userId; // 用户ID【发起方】
    private String friendUserId; // 目标方id【好友id或群组id，看是啥类型】
    private Integer talkType; // 对话框类型[0好友、1群组]

    @Override
    public Byte getCommand() {
        return Command.TalkNoticeRequest;
    }

}
```

org/chat/server/protocol/talk/TalkNoticeResponse.java
对话通知响应协议：对话框id + 展示该对话框需要的属性（名称，头像，简讯，时间）
```java
/**
 * 对话通知响应协议：对话框id + 展示该对话框需要的属性（名称，头像，简讯，时间）
 * @author XiaoRed
 * @date 2023/12/8 21:01
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class TalkNoticeResponse extends Packet {

    private String talkId;  // 对话框ID[好友ID、群ID]
    private String talkName; // 对话框名称[好友名称、群名称]
    private String talkHead; // 对话框头像[好友头像、群头像]
    private String talkSketch; // 消息简讯
    private Date talkDate; // 消息时间

    @Override
    public Byte getCommand() {
        return Command.TalkNoticeResponse;
    }
}
```

org/chat/server/protocol/talk/DelTalkRequest.java
删除对话框请求协议：发起方id + 要删除的对话框id
```java
/**
 * 删除对话框请求协议：发起方id + 要删除的对话框id
 * @author XiaoRed
 * @date 2023/12/8 21:03
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class DelTalkRequest extends Packet {

    private String userId; // 用户ID【谁要删对话框】
    private String talkId;  // 对话框ID【删哪个对话框】

    @Override
    public Byte getCommand() {
        return Command.DelTalkRequest;
    }

}
```

最后，记得往Command中添加这四个协议对应的指令码
还要记得把协议和指令码的对应关系保存到Packet的map中

## UI事件实现

客户端获取socket通信管道channel，将请求发送到服务端

org/chat/client/event/ChatEvent.java
```java
    /**
     * 对好友点击“发送消息”按钮时触发，向服务端发送对话通知请求
     */
    @Override
    public void doEventAddTalkUser(String userId, String userFriendId) {
        Channel channel = BeanUtil.getBean("Channel", Channel.class);
        channel.writeAndFlush(new TalkNoticeRequest(userId, userFriendId, 0));
    }

    /**
     * 对群组点击“发送消息”按钮时触发，向服务端发送对话通知请求
     */
    @Override
    public void doEventAddTalkGroup(String userId, String groupId) {
        Channel channel = BeanUtil.getBean("Channel", Channel.class);
        channel.writeAndFlush(new TalkNoticeRequest(userId, groupId, 1));
    }

    /**
     * 用户删除一个对话框时触发，向服务端发送删除对话框请求
     */
    @Override
    public void doEventDelTalkUser(String userId, String talkId) {
        Channel channel = BeanUtil.getBean("Channel", Channel.class);
        channel.writeAndFlush(new DelTalkRequest(userId, talkId));
    }
```

***
除此之外，ui工程还写好了两个方法，发起方会直接创建对应的对话框，并跳转到聊天界面
org/chat/ui/view/chat/ChatEventDefine.java
```java
    // 好友；开启与好友发送消息 [点击发送消息时候触发 -> 添加到对话框、选中、展示对话列表]
    public void doEventOpenFriendUserSendMsg(Button sendMsgButton, String userFriendId, String userFriendNickName, String userFriendHead) {
        sendMsgButton.setOnAction(event -> {
            // 1. 添加好友到对话框
            chatMethod.addTalkBox(0, 0, userFriendId, userFriendNickName, userFriendHead, null, null, true);
            // 2. 切换到对话框窗口
            switchBarChat(chatInit.$("bar_chat", Button.class), chatInit.$("group_bar_chat", Pane.class), true);
            switchBarFriend(chatInit.$("bar_friend", Button.class), chatInit.$("group_bar_friend", Pane.class), false);
            // 3. 事件处理；填充到对话框
            chatEvent.doEventAddTalkUser(chatInit.userId, userFriendId);
        });
    }

    // 群组；开启与群组发送消息
    public void doEventOpenFriendGroupSendMsg(Button sendMsgButton, String groupId, String groupName, String groupHead) {
        sendMsgButton.setOnAction(event -> {
            // 1. 添加好友到对话框
            chatMethod.addTalkBox(0, 1, groupId, groupName, groupHead, null, null, true);
            // 2. 切换到对话框窗口
            switchBarChat(chatInit.$("bar_chat", Button.class), chatInit.$("group_bar_chat", Pane.class), true);
            switchBarFriend(chatInit.$("bar_friend", Button.class), chatInit.$("group_bar_friend", Pane.class), false);
            // 3. 事件处理；填充到对话框
            chatEvent.doEventAddTalkGroup(chatInit.userId, groupId);
        });
    }
```

## 服务端处理请求

依照不同的对话框类型`talkType = 0(用户)/1(群组)`，来做不同的处理：
* 好友对话请求：将对话框进行落库操作，发起方与目标方都进行落库。然后发送对话通知响应【目标方看到的对话框】给好友（目标方）
* 群组通信请求：只是进行落库，并且只落自己（发起方）和群组的通信。因为这个时候并不能把所有群友逐个通知并进行落库，从流程上看也不是合理的。

服务端处理对话通知请求
org/chat/server/socket/handler/TalkNoticeHandler.java
```java
/**
 * 服务端处理对话通知请求
 * @author XiaoRed
 * @date 2023/12/8 21:48
 */
public class TalkNoticeHandler extends MyHandler<TalkNoticeRequest> {

    public TalkNoticeHandler(UserService userService) {
        super(userService);
    }

    @Override
    public void channelRead(Channel channel, TalkNoticeRequest msg) {
        logger.info("对话通知应答处理：{}", JSON.toJSONString(msg));

        switch (msg.getTalkType()) {
            //好友对话请求【单聊】
            case 0:
                // 1. 对话框数据落库
                userService.addTalkBoxInfo(msg.getUserId(), msg.getFriendUserId(), 0);
                userService.addTalkBoxInfo(msg.getFriendUserId(), msg.getUserId(), 0);
                // 2. 查询发起方的用户信息[将发起方发给目标方的对话框中]
                UserInfo userInfo = userService.queryUserInfo(msg.getUserId());
                // 3. 发送对话框消息给好友
                TalkNoticeResponse response = new TalkNoticeResponse();
                response.setTalkId(userInfo.getUserId());
                response.setTalkName(userInfo.getUserNickName());
                response.setTalkHead(userInfo.getUserHead());
                response.setTalkSketch(null);
                response.setTalkDate(new Date());
                // 获取好友通信管道，好友处于登录状态，才把响应发送给好友
                Channel friendChannel = SocketChannelUtil.getChannel(msg.getFriendUserId());
                if (null == friendChannel) {
                    logger.info("用户id：{}未登录！", msg.getFriendUserId());
                    return;
                }
                friendChannel.writeAndFlush(response);
                break;
            //群组通讯请求【群聊】
            case 1:
                userService.addTalkBoxInfo(msg.getUserId(), msg.getFriendUserId(), 1);
                break;
            default:
                break;
        }
    }
}
```

***
除此之外，还有处理删除对话框请求的处理器，这个比较简单，直接从数据库删对应id的记录就行
```java
/**
 * 服务端处理删除对话框请求
 * @author XiaoRed
 * @date 2023/12/8 22:06
 */
public class DelTalkHandler extends MyHandler<DelTalkRequest> {

    public DelTalkHandler(UserService userService) {
        super(userService);
    }

    @Override
    public void channelRead(Channel channel, DelTalkRequest msg) {
        userService.deleteUserTalk(msg.getUserId(), msg.getTalkId());
    }
}
```

最后记得往pipeline里添加上这两个handler

## 客户端处理响应

客户端处理对话通知响应
org/chat/client/socket/handler/TalkNoticeHandler.java
向聊天界面中添加对应的对话框（通过加载响应中传来的数据）
```java
/**
 * 客户端处理对话通知响应：向聊天界面中添加对应的对话框（通过加载响应中传来的数据）
 * @author XiaoRed
 * @date 2023/12/8 21:24
 */
public class TalkNoticeHandler extends SimpleChannelInboundHandler<TalkNoticeResponse> {

    private UIService uiService;

    public TalkNoticeHandler(UIService uiService) {this.uiService = uiService;}

    @Override
    protected void channelRead0(ChannelHandlerContext channelHandlerContext, TalkNoticeResponse msg) throws Exception {
        IChatMethod chat = uiService.getChat();
        Platform.runLater(() -> {
            chat.addTalkBox(-1, 0, msg.getTalkId(), msg.getTalkName(), msg.getTalkHead(), msg.getTalkSketch(), msg.getTalkDate(), false);
        });
    }
}
```

最后记得往pipeline里添加上这个handler

# 用户与好友通信

## 流程分析

step1：选中与好友通信的窗口。此时就可以拿到好友的ID，在点击发送消息的时候，将（好友ID、消息、时间、个人ID）封装为请求，发送给服务端。
step2：服务端收到数据后，首先是将消息**使用多线程进行异步落库**留存。接下来判断好友是否在线，只有好友在线，才能通过好友ID从服务端的 Map 结构中获取到通信渠道 Channel
step3：服务端获取到好友的 Channel 后，将消息发送给好友。好友收到消息后，通过UI的接口，将消息展示到界面上。

## 协议定义

org/chat/server/protocol/msg/MsgRequest.java
单聊消息请求协议
```java
/**
 * 单聊消息请求协议：发送方id + 目标方id + 消息内容 + 消息类型 + 消息时间
 * @author XiaoRed
 * @date 2023/12/8 23:44
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class MsgRequest extends Packet {

    private String userId;  // 用户ID[发送方我]
    private String friendId; // 好友ID[目标方]
    private String msgText;  // 传输消息内容
    private Integer msgType; // 消息类型；0文字消息、1表情包
    private Date msgDate; // 消息时间

    @Override
    public Byte getCommand() {
        return Command.MsgRequest;
    }

}
```

org/chat/server/protocol/msg/MsgResponse.java
单聊消息响应协议
```java
/**
 * 单聊消息响应协议：目标方id（转发给谁） + 消息内容 + 消息类型 + 消息时间
 * @author XiaoRed
 * @date 2023/12/8 23:45
 */
public class MsgResponse extends Packet {

    private String friendId; //好友ID[目标方]
    private String msgText;  //传输消息内容
    private Integer msgType; //消息类型；0文字消息、1固定表情
    private Date msgDate; // 消息时间

    @Override
    public Byte getCommand() {
        return Command.MsgResponse;
    }
}
```

最后，记得往Command中添加这四个协议对应的指令码
还要记得把协议和指令码的对应关系保存到Packet的map中

## UI事件实现

org/chat/client/event/ChatEvent.java
点击“发送消息”按钮后，向服务端发送单聊消息请求
```java
 @Override
    public void doSendMsg(String userId, String talkId, Integer talkType, String msg, Integer msgType, Date msgDate) {
        Channel channel = BeanUtil.getBean("Channel", Channel.class);
        if (0 == talkType) { // 好友0
            channel.writeAndFlush(new MsgRequest(userId, talkId, msg, msgType, msgDate));
        }else{
            //todo:发送群聊消息请求
        }
    }
```

***
UI工程中定义如下事件，触发上面的这个doSendMsg方法
先获取待发送的消息并进行简单的处理，然后通过触发doSendMsg将请求发送到服务端。同时，发送方自己的聊天对话界面也会同步自己发送的这条消息
```java
private void doEventSendMsg() {
        TextArea txt_input = chatInit.$("txt_input", TextArea.class);
        MultipleSelectionModel selectionModel = chatInit.$("talkList", ListView.class).getSelectionModel();
        Pane selectedItem = (Pane) selectionModel.getSelectedItem();
        // 对话信息
        TalkBoxData talkBoxData = (TalkBoxData) selectedItem.getUserData();
        String msg = txt_input.getText();
        if (null == msg || "".equals(msg) || "".equals(msg.trim())) {
            return;
        }
        Date msgDate = new Date();
        // 发送消息
        chatEvent.doSendMsg(chatInit.userId, talkBoxData.getTalkId(), talkBoxData.getTalkType(), msg, 0, msgDate);
        // 发送事件给自己添加消息
        chatMethod.addTalkMsgRight(talkBoxData.getTalkId(), msg, 0, msgDate, true, true, false);
        txt_input.clear();
    }
```

## 服务端处理请求

服务端处理单聊消息请求
* 将收到的请求中，聊天消息相关的信息进行**异步入库**
  org/chat/server/domain/user/service/UserServiceImpl.java
  ```java
  @Resource
  private ThreadPoolTaskExecutor taskExecutor;
  @Override
    public void asyncAppendChatRecord(final ChatRecordInfo chatRecordInfo) {
        taskExecutor.execute(new Runnable() {
            @Override
            public void run() {
                userRepository.appendChatRecord(chatRecordInfo);
            }
        });
    }
  ```
* 如果目标方还没有与发送方的对话框，则需要给目标方创建对应的对话框（入库，可以用redis优化）
* 获取好友channel，如果对方不在线，是获取不到的。如果获取到，则封装出单聊消息响应，发送给对方

org/chat/server/socket/handler/MsgHandler.java
```java
/**
 * 服务端处理单聊消息请求
 * @author XiaoRed
 * @date 2023/12/9 0:06
 */
public class MsgHandler extends MyHandler<MsgRequest> {

    public MsgHandler(UserService userService) {
        super(userService);
    }

    @Override
    public void channelRead(Channel channel, MsgRequest msg) {
        logger.info("消息信息处理：{}", JSON.toJSONString(msg));
        // 异步写库
        userService.asyncAppendChatRecord(new ChatRecordInfo(msg.getUserId(), msg.getFriendId(), msg.getMsgText(), msg.getMsgType(), msg.getMsgDate()));
        // 添加对话框[如果对方没有你的对话框则添加]
        userService.addTalkBoxInfo(msg.getFriendId(), msg.getUserId(), Constants.TalkType.Friend.getCode());
        // 获取好友通信管道
        Channel friendChannel = SocketChannelUtil.getChannel(msg.getFriendId());
        if (null == friendChannel) {
            logger.info("用户id：{}未登录！", msg.getFriendId());
            return;
        }
        // 发送消息
        friendChannel.writeAndFlush(new MsgResponse(msg.getUserId(), msg.getMsgText(), msg.getMsgType(), msg.getMsgDate()));
    }
}
```

最后记得往pipeline里添加上这个handler

## 客户端处理响应

org/chat/client/socket/handler/MsgHandler.java
客户端处理单聊消息响应：将接收到的消息展示到聊天记录的左侧（他人发来的消息）
```java
/**
 * 客户端处理单聊消息响应
 * @author XiaoRed
 * @date 2023/12/9 0:01
 */
public class MsgHandler extends SimpleChannelInboundHandler<MsgResponse> {
    private UIService uiService;

    public MsgHandler(UIService uiService) {
        this.uiService = uiService;
    }


    @Override
    protected void channelRead0(ChannelHandlerContext channelHandlerContext, MsgResponse msg) throws Exception {
        IChatMethod chat = uiService.getChat();
        Platform.runLater(() -> { //将接收到的消息展示到聊天记录的左侧（他人发来的消息）
            chat.addTalkMsgUserLeft(msg.getFriendId(), msg.getMsgText(), msg.getMsgType(), msg.getMsgDate(), true, false, true);
        });

    }
}
```

最后记得往pipeline里添加上这个handler

# 用户与群组通信

## 流程分析

群聊与单聊的流程还是比较像的，只是群聊的实现，在服务端需要使用到ChannelGroup。所以用户登录上线后，需要将自己的Channel，放到所有自己所在的群组的ChannelGroup中，这样才能收到群组的消息。

与单聊不同，发送群聊消息时，需要把自己的id、昵称、头像一并发送。可以把这些固定的信息保存到客户端本地，来节省通信时间损耗。【单聊是发送给好友个人，只需要发送好友ID、通信信息即可；群聊是发送给群组中的所有人，就需要将群组里的好友等信息一并发送过去；好友ID、好友头像、好友昵称。同样为了效率可以将这些信息进行缓存，以此提升通信效率。】

群聊消息同样使用异步落库的方式保存聊天记录，登录功能中，用户登录上线后，会从数据库中将聊天记录加载到聊天界面。

## 协议定义

org/chat/server/protocol/msg/MsgGroupRequest.java
群聊消息请求协议
```java
/**
 * 群聊消息请求协议：群组id + 发送方id + 消息内容 + 消息类型 + 消息时间
 * @author XiaoRed
 * @date 2023/12/9 8:50
 */
public class MsgGroupRequest extends Packet {

    private String talkId; //对话框ID，也就是群组id
    private String userId; //群员ID（发送方id）
    private String msgText; //传输消息内容
    private Integer msgType; //消息类型；0文字消息、1固定表情
    private Date msgDate; //消息时间


    @Override
    public Byte getCommand() {
        return Command.MsgGroupRequest;
    }
}
```

org/chat/server/protocol/msg/MsgGroupResponse.java
群聊消息响应协议
```java
/**
 * 群聊消息响应协议：群聊id + 发送方id + 发送方相关信息（名称，头像） + 消息内容 + 消息类型 + 消息时间
 * @author XiaoRed
 * @date 2023/12/9 8:57
 */
public class MsgGroupResponse extends Packet {

    private String talkId; //对话框ID，也就是群组id
    private String userId; //群员用户ID（发送方id）
    private String userNickName; //发送方昵称
    private String userHead; //发送方头像
    private String msg;  //群员用户发送消息内容
    private Integer msgType; //消息类型；0文字消息、1固定表情
    private Date msgDate;  // 群员用户发送消息时间

    @Override
    public Byte getCommand() {
        return Command.MsgGroupResponse;
    }
}
```

最后，记得往Command中添加这四个协议对应的指令码
还要记得把协议和指令码的对应关系保存到Packet的map中

## UI事件实现

org/chat/client/event/ChatEvent.java
通过talkType判断是单聊还是群聊，封装为对应的请求，发送给服务端
```java
    @Override
    public void doSendMsg(String userId, String talkId, Integer talkType, String msg, Integer msgType, Date msgDate) {
        Channel channel = BeanUtil.getBean("Channel", Channel.class);
        if (0 == talkType) { //单聊0
            channel.writeAndFlush(new MsgRequest(userId, talkId, msg, msgType, msgDate));
        }else{ //群聊1
           channel.writeAndFlush(new MsgGroupRequest(talkId, userId, msg, msgType, msgDate));
        }
    }
```

***
UI工程中定义如下事件，触发上面的这个doSendMsg方法
先获取待发送的消息并进行简单的处理，然后通过触发doSendMsg将请求发送到服务端。同时，发送方自己的聊天对话界面也会同步自己发送的这条消息
单聊群聊都走它，靠talktype区分

```java
private void doEventSendMsg() {
        TextArea txt_input = chatInit.$("txt_input", TextArea.class);
        MultipleSelectionModel selectionModel = chatInit.$("talkList", ListView.class).getSelectionModel();
        Pane selectedItem = (Pane) selectionModel.getSelectedItem();
        // 对话信息
        TalkBoxData talkBoxData = (TalkBoxData) selectedItem.getUserData();
        String msg = txt_input.getText();
        if (null == msg || "".equals(msg) || "".equals(msg.trim())) {
            return;
        }
        Date msgDate = new Date();
        // 发送消息
        chatEvent.doSendMsg(chatInit.userId, talkBoxData.getTalkId(), talkBoxData.getTalkType(), msg, 0, msgDate);
        // 发送事件给自己添加消息
        chatMethod.addTalkMsgRight(talkBoxData.getTalkId(), msg, 0, msgDate, true, true, false);
        txt_input.clear();
    }
```

## 服务端处理请求

LoginHandler：用户登录后，将用户与群组的channelGroup的对应关系存储起来，方便后续服务端处理群聊
```java
//1. 将用户与channel的对应关系存储起来，方便后续服务端处理聊天业务
SocketChannelUtil.addChannel(msg.getUserId(), channel);
//1.2 将用户与群组的channelGroup的对应关系存储起来，方便后续服务端处理群聊
List<String> groupsIdList = userService.queryUserGroupsIdList(msg.getUserId());
for (String groupId : groupsIdList) {
    SocketChannelUtil.addChannelGroup(groupId, channel);
}
```

服务端处理群聊消息请求
* 获取目标群组的ChannelGroup，没有则新建
* 聊天消息异步入库
* 封装响应
* 通过channelGroup，一次性将响应发送给group中所有的channel

 
org/chat/server/socket/MyChannelInitializer.java
```java
/**
 * 服务端处理群聊消息请求
 * @author XiaoRed
 * @date 2023/12/9 9:12
 */
public class MsgGroupHandler extends MyHandler<MsgGroupRequest> {

    public MsgGroupHandler(UserService userService) {
        super(userService);
    }

    @Override
    public void channelRead(Channel channel, MsgGroupRequest msg) {
        //获取目标群组的ChannelGroup，如果没有，就新建
        ChannelGroup channelGroup = SocketChannelUtil.getChannelGroup(msg.getTalkId());
        if (null == channelGroup) {
            SocketChannelUtil.addChannelGroup(msg.getTalkId(), channel);
            channelGroup = SocketChannelUtil.getChannelGroup(msg.getTalkId());
        }
        //将这个新的群聊消息异步入库
        userService.asyncAppendChatRecord(new ChatRecordInfo(msg.getUserId(), msg.getTalkId(), msg.getMsgText(), msg.getMsgType(), msg.getMsgDate(), Constants.TalkType.Group.getCode()));
        //封装响应
        UserInfo userInfo = userService.queryUserInfo(msg.getUserId());
        MsgGroupResponse msgGroupResponse = new MsgGroupResponse();
        msgGroupResponse.setTalkId(msg.getTalkId());
        msgGroupResponse.setUserId(msg.getUserId());
        msgGroupResponse.setUserNickName(userInfo.getUserNickName());
        msgGroupResponse.setUserHead(userInfo.getUserHead());
        msgGroupResponse.setMsg(msg.getMsgText());
        msgGroupResponse.setMsgType(msg.getMsgType());
        msgGroupResponse.setMsgDate(msg.getMsgDate());
        //通过channelGroup群发消息，将响应发送给group中所有的channel
        channelGroup.writeAndFlush(msgGroupResponse);
    }

}
```

最后记得往pipeline里添加上这个handler

## 客户端处理响应

org/chat/client/socket/handler/MsgGroupHandler.java
客户端处理群聊响应：和单聊是一样的，将新消息展示到聊天界面左侧
```java
/**
 * 客服端处理群聊消息响应
 * @author XiaoRed
 * @date 2023/12/9 9:09
 */
public class MsgGroupHandler extends SimpleChannelInboundHandler<MsgGroupResponse> {

    private UIService uiService;

    public MsgGroupHandler(UIService uiService) {
        this.uiService = uiService;
    }

    @Override
    protected void channelRead0(ChannelHandlerContext ctx, MsgGroupResponse msg) throws Exception {
        IChatMethod chat = uiService.getChat();
        Platform.runLater(() -> { //将新消息展示到聊天界面左侧
            chat.addTalkMsgGroupLeft(msg.getTalkId(), msg.getUserId(), msg.getUserNickName(), msg.getUserHead(), msg.getMsg(), msg.getMsgType(), msg.getMsgDate(), true, false, true);
        });
    }
}
```

最后记得往pipeline里添加上这个handler

***
群消息处理与好友消息会有不同的接口处理方法，群消息不同于好友消息：如果是好友消息，可以让服务端通知好友创建对话框；但是群聊消息中，不能通知群组创建对话框。

因此群聊消息的回显接口chat.addTalkMsgGroupLeft，来添加对话消息，同时会判断当前群组是否在对话框中，如果群组不在对话框，则创建对话框

UI工程 org/chat/ui/view/chat/ChatController.java
```java
@Override
    public void addTalkMsgGroupLeft(String talkId, String userId, String userNickName, String userHead, String msg, Integer msgType, Date msgDate, Boolean idxFirst, Boolean selected, Boolean isRemind) {
        // 自己的消息抛弃
        if (super.userId.equals(userId)) return;
        ElementTalk talkElement = CacheUtil.talkMap.get(talkId);
        if (null == talkElement) {
            GroupsData groupsData = (GroupsData) $(Ids.ElementTalkId.createFriendGroupId(talkId), Pane.class).getUserData();
            if (null == groupsData) return;
            addTalkBox(0, 1, talkId, groupsData.getGroupName(), groupsData.getGroupHead(), userNickName + "：" + msg, msgDate, false);
            talkElement = CacheUtil.talkMap.get(talkId);
            // 事件通知(开启与群组发送消息)
            chatEvent.doEventAddTalkGroup(super.userId, talkId);
        }
        ListView<Pane> listView = talkElement.infoBoxList();
        Pane left = new ElementInfoBox().left(userNickName, userHead, msg, msgType);
        // 消息填充
        listView.getItems().add(left);
        // 滚动条
        listView.scrollTo(left);
        talkElement.fillMsgSketch(0 == msgType ? userNickName + "：" + msg : userNickName + "：[表情]", msgDate);
        // 设置位置&选中
        chatView.updateTalkListIdxAndSelected(1, talkElement.pane(), talkElement.msgRemind(), idxFirst, selected, isRemind);
    }
```