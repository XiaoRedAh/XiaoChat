涉及的代码量太大了，因此只展示核心代码，重复较大的各种对象定义，crud等代码均不展示

# 登录功能

## 流程分析

step1：用户在窗体中发起登录事件，客户端向服务端发送登录请求
step2：服务端验证后，将验证结果以及初始化数据通过通信管道channel反馈给客户端。
step3：客户端依照服务端发来的验证结果，调用UI接口，执行登录成功或者提示登录失败操作

## 协议定义

这部分编写的是chat-server-agreement模块，涉及protocol包下的内容：
```
protocol
│  Command.java
│  Packet.java
│
└─login
    │  LoginRequest.java
    │  LoginResponse.java
    │
    └─dto
            ChatRecordDto.java
            GroupsDto.java
            TalkBoxDto.java
            UserFriendDto.java
```
定义了登录请求和登录响应的协议格式，及它们需要在传输过程中负载的dto对象

***

登录请求 org/chat/server/protocol/login/LoginRequest.java
```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class LoginRequest extends Packet {
    private String userId;
    private String userPassword;
}
```

登录响应 org/chat/server/protocol/login/LoginResponse.java
不仅包含了用户的基本信息，还有一些初始化数据；对话框、个人群组、个人好友
```java
/**
 * 登录响应协议：是否成功 + 用户基本信息 + 初始化数据（对话框，好友，群组）
 * @author XiaoRed
 * @date 2023/12/1 18:56
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class LoginResponse extends Packet {
    Boolean success; //登录成功为true
    private String userId; // 用户ID
    private String userNickName; //用户昵称
    private String userHead;  //用户头像
    private List<TalkBoxDto> chatTalkList = new ArrayList<>(); //聊天对话框数据
    private List<UserFriendDto> userFriendList = new ArrayList<>(); //加载好友列表
    private List<GroupsDto> groupsList = new ArrayList<>(); //加载群组列表

    @Override
    public Byte getCommand() {
        return Command.LoginResponse;
    }

    public boolean isSuccess() {
        return success;
    }
}
```

最后，往Command中，添加这两个协议的指令码

## UI登录事件实现

>在UI模块开发中，已经定义好了接口事件ILoginEvent，现在只需要在客户端做具体的功能实现即可，体现了架构设计时说到的UI与业务逻辑分离。

客户端获取socket通信管道channel，将登录请求发送到服务端
org/chat/client/event/LoginEvent.java
```java
/**
 * 实现UI登录事件
 * @author XiaoRed
 * @date 2023/11/30 18:48
 */
public class LoginEvent implements ILoginEvent {
    /**
     * 客户端将登录请求发送给服务端校验
     */
    @Override
    public void doLoginCheck(String userId, String userPassword) {
        Channel channel = BeanUtil.getBean("Channel");
        //客户端通过连接的信道，直接将登录请求发送给服务端校验
        channel.writeAndFlush(new LoginRequest(userId, userPassword));
        //todo：断线重连业务
    }
}
```
做断线重连功能时，要将用户ID一起发送给服务端，因此将来这里要搞个缓存，记录当前用户id

## 服务端处理登录请求

针对这个业务，用户领域的model添加如下对象
```
domain
├─inet
│  ├─model
│  ├─repository
│  └─service
└─user
    ├─model
    │      ChatRecordInfo.java
    │      GroupsInfo.java
    │      TalkBoxInfo.java
    │      UserFriendInfo.java
    │      UserGroupInfo.java
    │      UserInfo.java
    │
    ├─repository
    │      IUserRepository.java
    │
    └─service
            UserServiceImpl.java
```

处理登录的handler：org/chat/server/socket/handler/LoginHandler.java
* 指定LoginRequest泛型，该handler只会处理LoginRequest类型的数据
* 创建后，记得把它添加到pipeline中去

处理逻辑：
如果是验证用户身份信息不通过，则进行反馈：channel.writeAndFlush(new LoginResponse(false));
如果是验证用户身份信息通过
* 将用户ID与通信管道Channel的对应关系记录下来，为后续服务端实现通信功能做准备
* 基本数据的初始化，在登录后就可以看到群组、好友、对话、聊天记录等。【这里涉及对象转换和大量crud】

```java
/**
 * 登录业务处理
 * @author XiaoRed
 * @date 2023/12/1 23:38
 */
public class LoginHandler extends MyHandler<LoginRequest> {

    public LoginHandler(UserService userService){super(userService);}
    @Override
    public void channelRead(Channel channel, LoginRequest msg) {
        logger.info("正在处理登录请求：", JSON.toJSON(msg));
        boolean success = userService.checkAuth(msg.getUserId(), msg.getUserPassword());
        if(!success){ //登录校验不通过
            channel.writeAndFlush(new LoginResponse(false));
            return;
        }
        //登录校验通过
        //1. 将用户与channel的对应关系存储起来，方便后续服务端处理聊天业务
        SocketChannelUtil.addChannel(msg.getUserId(), channel);
        //2. 初始化数据：用户信息
        UserInfo userInfo = userService.queryUserInfo(msg.getUserId());
        //3. 初始化数据：好友列表
        List<UserFriendInfo> friendInfos = userService.queryUserFriendInfoList(msg.getUserId());
        //4. 初始化数据：群组列表
        List<GroupsInfo> groupsInfos = userService.queryGroupsInfoList(msg.getUserId());
        //5. 初始化数据：聊天框
        List<TalkBoxInfo> talkBoxInfos = userService.queryTalkBoxInfoList(msg.getUserId());
        //6. 封装LoginResponse对象
        LoginResponse loginResponse = new LoginResponse();
        ...
        ...加载各种初始化数据，一大堆的crud
        ...
        loginResponse.setSuccess(true);
        loginResponse.setUserId(userInfo.getUserId());
        loginResponse.setUserNickName(userInfo.getUserNickName());
        loginResponse.setUserHead(userInfo.getUserHead());
        //7. 通过channel向客户端响应LoginResponse
        channel.writeAndFlush(loginResponse);
    }
}
```

## 客户端处理登录响应

登录处理handler：org/chat/client/socket/handler/LoginHandler.java
* 指定LoginResponse泛型，该handler只会处理LoginResponse类型的数据
* 创建后，记得把它添加到pipeline中去

处理逻辑：
拿到响应后，先通过响应对象的isSuccess方法判断是否登录成功，如果不成功，打印登录失败，直接返回；
如果登录成功
* 通过UIService执行登录界面的成功事件（关闭），并将主界面chat展示
* 将响应对象里面携带的初始化数据展示到主界面chat中
```java
/**
 * 客户端处理登录响应
 * @author XiaoRed
 * @date 2023/12/2 8:31
 */
public class LoginHandler extends SimpleChannelInboundHandler<LoginResponse> {

    private UIService uiService;

    public LoginHandler(UIService uiService) {
        this.uiService = uiService;
    }

    @Override
    protected void channelRead0(ChannelHandlerContext ctx, LoginResponse msg) throws Exception {
        System.out.println("\r\n> msg handler ing ...");
        System.out.println("收到登录响应消息：" + JSON.toJSONString(msg));
        if (!msg.isSuccess()) {
            System.out.println("登录失败...");
            return;
        }
        //在非Fx线程中操作JavaFx线程相关任务时，需要在Platform.runLater中执行，但它不是线程阻塞型的，在javafx的主线程完全清空或者空闲的时候，才会执行
        Platform.runLater(() -> {
            uiService.getLogin().doLoginSuccess();
            IChatMethod chat = uiService.getChat();
            ...
            ...将登录响应中的初始化数据展示到chat界面
            ...
            }
        );
    }
}
```