# 服务端架构设计

在设计架构之前，明确这个系统有什么需求目标：
* 系统在服务端要有web页面进行管理通信用户，以及服务端的控制和监控。
* 数据库的对象类，不要被外部污染，要有隔离性
* 使用Netty进行通信，服务端与客户端都会用到通信过程中的协议定义和解析。因此需要抽离出这一层，对外提供Jar包。
* 接口、业务处理、底层服务、通信交互，要有明确的区分和实现，避免造成混乱难以维护

在这之前，我都是用`MVC三层架构`来开发的，它的分层非常清晰，也不复杂，很好上手。但是随着系统功能不断叠加，MVC架构的代码维护越来越难。
* 就拿vo类来说，每次新添业务后，都想直接复用之前写好的vo，于是直接往里面多丢几个属性，久而久之，这个vo越来越庞大，已经看不清最初的样子了，都不知到它来干嘛的，并且被多个业务代码交叉引用，维护很困难。
* model的功能很单一，只提供get/set，并没有跟随业务走，随着开发代码的不断增多，最后难以维护。

于是在这个项目中，我第一次运用到了`DDD四层架构`来开发【当然，业务没有复杂到那个地步，因此属于轻量级的四层架构】
>**应用层{application}**
>对微服务内的领域服务以及微服务外的应用服务进行组合和编排
>对基础层如文件、缓存等数据直接操作形成应用服务，对外提供粗粒度的服务
>领域事件的发布和订阅。通过事件总线和消息队列实现异步数据传输，实现微服务之间的解耦。
>
>**领域层{domain}**
>领域服务位于领域层，为完成领域中跨实体或值对象的操作转换而封装的服务，领域服务以与实体和值对象相同的方式参与实施过程。
>领域服务对同一个实体的一个或多个方法进行组合和封装，或对多个不同实体的操作进行组合或编排，对外暴露成领域服务。
>领域服务封装了核心的业务逻辑。实体自身的行为在实体类内部实现，向上封装成领域服务暴露。
>为隐藏领域层的业务逻辑实现，所有领域方法和服务等均须通过领域服务对外暴露。
>为实现微服务内聚合之间的解耦，原则上禁止跨聚合的领域服务调用和跨聚合的数据相互关联。
>
>**基础层{infrastructrue}**
基础服务位于基础层。为各层提供资源服务（如数据库、缓存等），实现各层的解耦，降低外部资源变化对业务逻辑的影响。
基础服务主要为仓储服务，通过依赖反转的方式为各层提供基础资源服务，领域服务和应用服务调用仓储服务接口，利用仓储实现持久化数据对象或直接访问基础资源。
>
>**接口层{interfaces}**
>接口服务位于用户接口层，用于处理用户发送的Restful请求和解析用户输入的配置文件等，并将信息传递给应用层。

总的来说，设计出：接口层、业务层、领域层、基础层这四个层级，每一个层级负责不同的内容，并且以领域设计为核心。
这个项目中再额外拓展一个通信层，负责Socket服务端对业务流程的处理和数据转发服务，同时将一些数据，聊天记录等进行落库操作。
比如下面这个例子【简单的demo，随着业务的跟进，会有对应的拓展和改变】
```
chat-server
└── src
    ├── main
    │   ├── java
    │   │   └── org.example
    │   │       ├── application
    │   │       │	├── event
    │   │       │	│   └── ApplicationRunner.java
    │   │       │	└── service
    │   │       │	    └── UserService.java	
    │   │       ├── domain
    │   │       │	├── model
    │   │       │	│   ├── aggregates
    │   │       │	│   │   └── UserRichInfo.java
    │   │       │	│   └── vo
    │   │       │	│       ├── UserInfo.java	
    │   │       │	│       └── UserSchool.java	
    │   │       │	├── repository
    │   │       │	│   └── IuserRepository.java
    │   │       │	└── service
    │   │       │	    └── UserServiceImpl.java	
    │   │       ├── infrastructure
    │   │       │	├── dao
    │   │       │	│   ├── impl
    │   │       │	│   │   └── UserDaoImpl.java
    │   │       │	│   └── UserDao.java	
    │   │       │	├── po
    │   │       │	│   └── UserEntity.java	
    │   │       │	├── repository
    │   │       │	│   ├── mysql
    │   │       │	│   │   └── UserMysqlRepository.java
    │   │       │	│   ├── redis
    │   │       │	│   │   └── UserRedisRepository.java
    │   │       │	│   └── UserRepository.java	
    │   │       │	└── util
    │   │       │	    └── RedisUtil.java
    │   │       ├── interfaces
    │   │       │	├── dto
    │   │       │	│	└── UserInfoDto.java	
    │   │       │	└── facade
    │   │       │		└── DDDController.java
    │   │       └── DDDApplication.java
    │   ├── resources	
    │   │   └── application.yml
    │   └── webapp	
    │       └── WEB-INF
    │        	└── index.jsp	
    └── test
         └── java
             └── org.example.demo.test
                 └── ApiTest.java
```

这里的数据库层、业务层，到最终对外的接口层，所有的对象类都是相互隔离不会造成污染的。
除了添加Socket功能外，没有其他的扩展(如mq，定时任务处理等)，所以比较轻量级的。

# Netty数据传输基础

Netty使用基本框架：

启动类配置，

自定义ChannelInitializer，初始化数据通信管道pipeline：预处理 + 业务处理
>服务端和客户端在这里的内容基本一致，特别对数据的解码编码必须是一个处理方式，否则数据不能正常通信。
* 解决半包、粘包等问题：需要定义一条数据的开始、长度、结尾、以及中间数据帧判断等
* 数据解析转换：socket通信过程中，不会直接发送字符串，而是一串串的二进制数据，这些数据在Netty中会被ByteBuf进行解析转换，最终发给下一层进行处理，使用不同的解析，解码&编码器，就会得到不同的数据对象
* 自定义数据处理类(继承自ChannelInboundHandlerAdapter)，承担数据的业务处理


## Netty字符串传输

在实际开发中，希望传输的数据不是字节码，而是一个字符串

管道中添加`StringDecoder`：自动的把接收到的Bytebuf数据转（解码为）String，不需要手动处理
管道中添加`StringEncoder`：自动的把待发送的String转（编码为）Bytebuf数据，不需要手动处理
解决半包粘包的问题：netty提供了很丰富的解码器，在正确的使用下就能解决半包粘包问题，常用的有
* `LineBasedFrameDecoder` 换行作为包结束符
* `DelimiterBasedFrameDecoder` 指定字符串作为包结束符
* `FixedLengthFrameDecoder` 基于字符串长度

***
**例子**
```
├─src
│  ├─main
│  │  ├─java
│  │  │  └─org
│  │  │      └─example
│  │  │          ├─client
│  │  │          │      MyChannelInitializer.java
│  │  │          │      MyClientHandler.java
│  │  │          │      NettyClient.java
│  │  │          │
│  │  │          └─server
│  │  │                  MyChannelInitializer.java
│  │  │                  MyServerHandler.java
│  │  │                  NettyServer.java
│  │  │
│  │  └─resources
│  └─test
│      └─java
└─target
```

**客户端**
org/example/client/NettyClient.java
```java
public class NettyClient {

    public static void main(String[] args) {
        new NettyClient().connect("127.0.0.1", 3000);
    }

    public void connect(String host, int port){
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        try{
            Bootstrap bootstrap = new Bootstrap();//客户端启动类是Bootstrap
            bootstrap
                    .group(workerGroup)
                    .channel(NioSocketChannel.class) //客户端channel是NioSocketChannel类型的
                    .option(ChannelOption.AUTO_READ, true) //数据准备好被读取时，Channel会自动从网络中读取，避免处理数据时手动调用read()方法
                    .handler(new MyChannelInitializer()); //利用自定义的initializer初始化handler更加灵活
            //指定目标服务端的主机地址和端口号
            ChannelFuture future = bootstrap.connect(host, port).sync(); //同步阻塞，直到连接建立完成或抛出异常
            System.out.println("客户端启动成功");
            future.channel().close().sync(); //同步阻塞，直到连接关闭完成或抛出异常
        } catch (InterruptedException e) {
            e.printStackTrace();
        }finally {
            workerGroup.shutdownGracefully(); //用完后要关闭
        }

    }
}
```

org/example/client/MyChannelInitializer.java
```java
public class MyChannelInitializer extends ChannelInitializer<SocketChannel> {
    
    @Override
    protected void initChannel(SocketChannel channel) throws Exception {
        channel.pipeline()
                .addLast(new LineBasedFrameDecoder(1024)) //以换行符作为包结束标志，最大1024
                .addLast(new StringDecoder(Charset.forName("GBK")))
                .addLast(new StringEncoder(Charset.forName("GBK")))
                .addLast(new MyClientHandler());
    }
}
```

org/example/client/MyClientHandler.java
```java
public class MyClientHandler extends ChannelInboundHandlerAdapter {

    /**
     * 客户端主动连接上服务端后，通道进入active状态，此时客户端和服务端可以互相传输数据
     */
    @Override
    public void channelActive(ChannelHandlerContext ctx) throws Exception {
        SocketChannel channel = (SocketChannel) ctx.channel(); //获取到数据发送方（服务端）的管道
        System.out.println("info-begin ...");
        System.out.println("info：客户端连接到服务端，channel id：" + channel.id());
        System.out.println("info-ip：" + channel.localAddress().getHostString());
        System.out.println("info-port：" + channel.localAddress().getPort());
        System.out.println("info-end ...");
        String msg = "通知服务端链接建立成功 " + new Date() + channel.localAddress().getHostString() + "\r\n";
        ctx.writeAndFlush(msg);
    }

    /**
     * 当客户端主动断开服务端的链接后，通道进入inactive状态。客户端与服务端不可以传输数据
     */
    @Override
    public void channelInactive(ChannelHandlerContext ctx) throws Exception {
        System.out.println("断开连接" + ctx.channel().localAddress().toString());
    }

    /**
     * 检测到通道中有新的数据，通道进入read状态，可以读取该数据
     */
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        System.out.println(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date()) + " 接收到消息：" + msg);
        ctx.writeAndFlush("客户端收到：" + new Date() + "\r\n");
    }

    /**
     * 发生异常时，可以进行打印日志，关闭连接等操作
     */
    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        ctx.close();
        System.out.println("异常信息：\r\n" + cause.getMessage());
    }
}
```

**服务端**
org/example/server/NettyServer.java
```java
public class NettyServer {

    public static void main(String[] args) {
        new NettyServer().bing(3000);
    }

    public void bing(int port){
        EventLoopGroup bossGroup = new NioEventLoopGroup();
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        try{
            ServerBootstrap bootstrap = new ServerBootstrap(); //服务端启动类是ServerBootstrap
            bootstrap
                    .group(bossGroup, workerGroup)
                    .channel(NioServerSocketChannel.class) //服务端channel是NioServerSocketChannel类型的
                    .option(ChannelOption.SO_BACKLOG, 128) //服务端accept队列的大小，当队列已满时，新的连接请求将会被拒绝。
                    .childHandler(new MyChannelInitializer()); //利用自定义的initializer初始化handler更加灵活
            //绑定服务端监听的端口号
            ChannelFuture future = bootstrap.bind(port).sync(); //同步阻塞，直到连接建立完成或抛出异常
            System.out.println("服务端启动成功...");
            future.channel().closeFuture().sync(); //同步阻塞，直到连接关闭完成或抛出异常
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }finally {
            bossGroup.shutdownGracefully();
            workerGroup.shutdownGracefully();
        }
    }
}
```

org/example/server/MyChannelInitializer.java
```java
public class MyChannelInitializer extends ChannelInitializer<SocketChannel> {
    @Override
    protected void initChannel(SocketChannel channel) throws Exception {
        channel.pipeline()
                .addLast(new LineBasedFrameDecoder(1024)) //以换行符作为包结束标志，最大1024
                .addLast(new StringDecoder(Charset.forName("GBK")))
                .addLast(new StringEncoder(Charset.forName("GBK")))
                .addLast(new MyServerHandler());
    }
}
```

org/example/server/MyServerHandler.java
```java
public class MyServerHandler extends ChannelInboundHandlerAdapter {

    /**
     * 客户端主动连接上服务端后，通道进入active状态，此时客户端和服务端可以互相传输数据
     */
    @Override
    public void channelActive(ChannelHandlerContext ctx) throws Exception {
        SocketChannel channel = (SocketChannel) ctx.channel(); //获取到数据发送方（服务端）的管道
        System.out.println("info-begin ...");
        System.out.println("info：有客户端连接到本服务端");
        System.out.println("info-ip：" + channel.localAddress().getHostString());
        System.out.println("info-port：" + channel.localAddress().getPort());
        System.out.println("info-end ...");
        String msg = "通知客户端链接建立成功 " + new Date() + channel.localAddress().getHostString() + "\r\n";
        ByteBuf buf = Unpooled.buffer(msg.getBytes().length);
        buf.writeBytes(msg.getBytes("GBK"));
        ctx.writeAndFlush(buf);
    }

    /**
     * 当客户端主动断开服务端的链接后，通道进入inactive状态。客户端与服务端不可以传输数据
     */
    @Override
    public void channelInactive(ChannelHandlerContext ctx) throws Exception {
        System.out.println("客户端断开连接" + ctx.channel().localAddress().toString());
    }

    /**
     * 检测到通道中有新的数据，通道进入read状态，可以读取该数据
     */
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        System.out.println(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date()) + " 接收到消息：" + msg);
        ctx.writeAndFlush("服务端收到：" + new Date() + "\r\n");
    }

    /**
     * 发生异常时，可以进行打印日志，关闭连接等操作
     */
    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        ctx.close();
        System.out.println("异常信息：\r\n" + cause.getMessage());
    }
}
```

**测试**
先启动服务端，后启动客户端
服务端控制台：
```
服务端启动成功...
info-begin ...
info：有客户端连接到本服务端
info-ip：127.0.0.1
info-port：3000
info-end ...
2023-11-30 13:23:25 接收到消息：通知服务端链接建立成功 Thu Nov 30 13:23:25 CST 2023127.0.0.1
客户端断开连接/127.0.0.1:3000
```

客户端控制台：
这里端口3000，是因为TCP连接开了一个临时端口
```
客户端启动成功
info-begin ...
info：客户端连接到服务端，channel id：81624497
info-ip：127.0.0.1
info-port：4120
info-end ...
断开连接/127.0.0.1:4120
```

## Netty对象传输

实际开发中，希望传输的数据是对象
* 将接收到的Bytebuf数据转换为指定的业务对象
* 将待发送的业务对象转换为Bytebuf数据发送


一个方案是，既然实现了传输字符串，那就可以传输Json，然后再转换为对象对象
但是这里有效率更高的方法：采用protobufs进行传输

>protocol buffers 是一种语言无关、平台无关、可扩展的序列化结构数据的方法，它可用于（数据）通信协议、数据存储等。Protocol Buffers 是一种灵活，高效，自动化机制的结构数据序列化方法－可类比 XML，但是比 XML 更小（3 ~ 10倍）、更快（20 ~ 100倍）、更为简单。

引入依赖
```xml
    <properties>
        <!-- Protostuff -->
        <protostuff.version>1.0.10</protostuff.version>
        <objenesis.version>2.4</objenesis.version>
    </properties>
    <dependency>
        <groupId>com.dyuproject.protostuff</groupId>
        <artifactId>protostuff-core</artifactId>
        <version>${protostuff.version}</version>
    </dependency>
    <dependency>
        <groupId>com.dyuproject.protostuff</groupId>
        <artifactId>protostuff-runtime</artifactId>
        <version>${protostuff.version}</version>
    </dependency>
    <dependency>
        <groupId>org.objenesis</groupId>
        <artifactId>objenesis</artifactId>
        <version>${objenesis.version}</version>
    </dependency>
```


***

**例子**
用MsgInfo模拟需要传输的Java对象，自定义编码器，解码器，将字节转换为对应的对象（本例中是MsgInfo）
```
├─src
│  ├─main
│  │  ├─java
│  │  │  └─org
│  │  │      └─example
│  │  │          ├─client
│  │  │          │      MyChannelInitializer.java
│  │  │          │      MyClientHandler.java
│  │  │          │      NettyClient.java
│  │  │          │
│  │  │          ├─codec
│  │  │          │      ObjDecoder.java
│  │  │          │      ObjEncoder.java
│  │  │          │
│  │  │          ├─domain
│  │  │          │      MsgInfo.java
│  │  │          │
│  │  │          ├─server
│  │  │          │      MyChannelInitializer.java
│  │  │          │      MyServerHandler.java
│  │  │          │      NettyServer.java
│  │  │          │
│  │  │          └─util
│  │  │                  MsgUtil.java
│  │  │                  SerializationUtil.java
│  │  │
│  │  └─resources
│  └─test
│      └─java
└─target
```

**自定义对象解码器**org/example/codec/ObjDecoder.java
```java
/**
 * 自定义对象解码器，继承自ByteToMessageDecoder，将接收到的字节转换为指定对象
 * @author XiaoRed
 * @date 2023/11/30 13:39
 */
public class ObjDecoder extends ByteToMessageDecoder {

    private Class<?> genericClass;

    public ObjDecoder(Class<?> genericClass){
        this.genericClass = genericClass;
    }

    @Override
    protected void decode(ChannelHandlerContext ctx, ByteBuf byteBuf, List<Object> list) throws Exception {
        if (byteBuf.readableBytes() < 4) return;
        byteBuf.markReaderIndex();
        int dataLength = byteBuf.readInt();
        if(byteBuf.readableBytes() < dataLength){
            byteBuf.resetReaderIndex();
            return;
        }
        byte[] data = new byte[dataLength];
        byteBuf.readBytes(data);
        list.add(SerializationUtil.deserialize(data, genericClass));
    }
}
```

**自定义对象编码器**org/example/codec/ObjEncoder.java
```java
/**
 * 自定义对象编码器，继承自MessageToByteEncoder，将待发送的业务对象转换为字节
 * @author XiaoRed
 * @date 2023/11/30 13:39
 */
public class ObjEncoder extends MessageToByteEncoder {

    private Class<?> genericClass;

    public ObjEncoder(Class<?> genericClass) {
        this.genericClass = genericClass;
    }

    @Override
    protected void encode(ChannelHandlerContext channelHandlerContext, Object o, ByteBuf byteBuf) throws Exception {
        if (genericClass.isInstance(o)) {
            byte[] data = SerializationUtil.serialize(o);
            byteBuf.writeInt(data.length);
            byteBuf.writeBytes(data);
        }
    }
}
```

**序列化工具类**org/example/util/SerializationUtil.java
```java
/**
 * @author XiaoRed
 * @date 2023/11/30 13:41
 */
public class SerializationUtil {

    private static Map<Class<?>, Schema<?>> cachedSchema = new ConcurrentHashMap<>();

    private static Objenesis objenesis = new ObjenesisStd();

    private SerializationUtil() {

    }

    /**
     * 序列化(对象 -> 字节数组)
     * @param obj 对象
     * @return 字节数组
     */
    public static <T> byte[] serialize(T obj) {
        Class<T> cls = (Class<T>) obj.getClass();
        LinkedBuffer buffer = LinkedBuffer.allocate(LinkedBuffer.DEFAULT_BUFFER_SIZE);
        try {
            Schema<T> schema = getSchema(cls);
            return ProtostuffIOUtil.toByteArray(obj, schema, buffer);
        } catch (Exception e) {
            throw new IllegalStateException(e.getMessage(), e);
        } finally {
            buffer.clear();
        }
    }

    /**
     * 反序列化(字节数组 -> 对象)
     * @param data
     * @param cls
     * @param <T>
     */
    public static <T> T deserialize(byte[] data, Class<T> cls) {
        try {
            T message = objenesis.newInstance(cls);
            Schema<T> schema = getSchema(cls);
            ProtostuffIOUtil.mergeFrom(data, message, schema);
            return message;
        } catch (Exception e) {
            throw new IllegalStateException(e.getMessage(), e);
        }
    }

    private static <T> Schema<T> getSchema(Class<T> cls) {
        Schema<T> schema = (Schema<T>) cachedSchema.get(cls);
        if (schema == null) {
            schema = RuntimeSchema.createFrom(cls);
            cachedSchema.put(cls, schema);
        }
        return schema;
    }
}
```

**客户端**
org/example/client/NettyClient.java
```java
public class NettyClient {

    public static void main(String[] args) {
        new NettyClient().connect("127.0.0.1", 3000);
    }

    public void connect(String host, int port){
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        try{
            Bootstrap bootstrap = new Bootstrap();//客户端启动类是Bootstrap
            bootstrap
                    .group(workerGroup)
                    .channel(NioSocketChannel.class) //客户端channel是NioSocketChannel类型的
                    .option(ChannelOption.AUTO_READ, true) //数据准备好被读取时，Channel会自动从网络中读取，避免处理数据时手动调用read()方法
                    .handler(new MyChannelInitializer()); //利用自定义的initializer初始化handler更加灵活
            //指定目标服务端的主机地址和端口号
            ChannelFuture future = bootstrap.connect(host, port).sync(); //同步阻塞，直到连接建立完成或抛出异常
            System.out.println("客户端启动成功");
            //测试：向服务端发送Java对象
            future.channel().writeAndFlush(MsgUtil.buildMsg(future.channel().id().toString(),"你好啊"));
            future.channel().writeAndFlush(MsgUtil.buildMsg(future.channel().id().toString(),"你好呦"));
            future.channel().close().sync(); //同步阻塞，直到连接关闭完成或抛出异常
        } catch (InterruptedException e) {
            e.printStackTrace();
        }finally {
            workerGroup.shutdownGracefully(); //用完后要关闭
        }

    }
}
```

org/example/client/MyChannelInitializer.java
```java
public class MyChannelInitializer extends ChannelInitializer<SocketChannel> {
    @Override
    protected void initChannel(SocketChannel channel) throws Exception {
        channel.pipeline()
                .addLast(new ObjDecoder(MsgInfo.class)) //将接收到的字节转换为MsgInfo对象
                .addLast(new ObjEncoder(MsgInfo.class)) //将待发送的MsgInfo对象转化为字节
                .addLast(new MyClientHandler());
    }
}
```

org/example/client/MyClientHandler.java
测试：打印对象类信息及其内容，以判断是否正常传输
```java
public class MyClientHandler extends ChannelInboundHandlerAdapter {
    ...
    /**
     * 检测到通道中有新的数据，通道进入read状态，可以读取该数据
     */
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        System.out.println(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date()) + " 接收到消息的类型：" + msg.getClass());
        System.out.println(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date()) + " 接收到消息内容：" + JSON.toJSONString(msg));
    }
    ...
}
```

**服务端**
org/example/server/NettyServer.java
```java
public class NettyServer {

    public static void main(String[] args) {
        new NettyServer().bing(3000);
    }

    public void bing(int port){
        EventLoopGroup bossGroup = new NioEventLoopGroup();
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        try{
            ServerBootstrap bootstrap = new ServerBootstrap(); //服务端启动类是ServerBootstrap
            bootstrap
                    .group(bossGroup, workerGroup)
                    .channel(NioServerSocketChannel.class) //服务端channel是NioServerSocketChannel类型的
                    .option(ChannelOption.SO_BACKLOG, 128) //服务端accept队列的大小，当队列已满时，新的连接请求将会被拒绝。
                    .childHandler(new MyChannelInitializer()); //利用自定义的initializer初始化handler更加灵活
            //绑定服务端监听的端口号
            ChannelFuture future = bootstrap.bind(port).sync(); //同步阻塞，直到连接建立完成或抛出异常
            System.out.println("服务端启动成功...");
            future.channel().closeFuture().sync(); //同步阻塞，直到连接关闭完成或抛出异常
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }finally {
            bossGroup.shutdownGracefully();
            workerGroup.shutdownGracefully();
        }
    }
}
```

org/example/server/MyChannelInitializer.java
```java
public class MyChannelInitializer extends ChannelInitializer<SocketChannel> {
    @Override
    protected void initChannel(SocketChannel channel) throws Exception {
        channel.pipeline()
                .addLast(new ObjDecoder(MsgInfo.class)) //将接收到的字节转换为MsgInfo对象
                .addLast(new ObjEncoder(MsgInfo.class)) //将待发送的MsgInfo对象转化为字节
                .addLast(new MyClientHandler());
    }
}
```

org/example/server/MyServerHandler.java
测试：打印对象类信息及其内容，以判断是否正常传输
```java
public class MyClientHandler extends ChannelInboundHandlerAdapter {
    ...
    /**
     * 检测到通道中有新的数据，通道进入read状态，可以读取该数据
     */
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        System.out.println(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date()) + " 接收到消息的类型：" + msg.getClass());
        System.out.println(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date()) + " 接收到消息内容：" + JSON.toJSONString(msg));
    }
    ...
}
```

**测试**
先启动服务端，后启动客户端
服务端控制台成功接收到客户端发送的Java对象：
```
2023-11-30 14:17:15 接收到消息的类型：class org.example.domain.MsgInfo
2023-11-30 14:17:15 接收到消息内容：{"channelId":"d5d6fc74","msgContent":"你好啊"}
2023-11-30 14:17:15 接收到消息的类型：class org.example.domain.MsgInfo
2023-11-30 14:17:15 接收到消息内容：{"channelId":"d5d6fc74","msgContent":"你好呦"}
```

# 通信协议设计

## 定义通信协议包

在实际通信过程中，涉及到各种各样的业务对象传输，如果对每种都创建对应的编码&解码器，代码即难看，又难维护，冗余也很多，拓展性也不行

因此需要定义统一的通信协议包如下

|帧长(int)|指令码(Byte)|数据(Byte[])|
|--|--|--|

* **帧长**：用于帧定界，解决粘包，半包等问题
* **指令码**：通过它来判断将数据解析成哪个业务对象，避免大量if语句判断，使得业务更加清晰
* **数据**：业务对象序列化位Byte[]传输

这样设计后，通道中传输的，都是格式一致的ByteBuf协议包，编码&解码流程都得到了统一
* decode解码：接收到Bytebuf数据后，先根据协议包格式，分别获取包的三个部分，然后再转换为对应的业务对象
* encode编码：将待发送的业务对象转换为ByteBuf数据，然后根据这三个部分，封装为统一的通信协议格式

## 初始化协议工程

统一的通信协议是服务端与客户端都要用到的，因此把它单独设计为一个协议工程
在chat-server模块下添加chat-server-agreement子模块，专门负责通信时的协议，初步构建模块结构如下
```
chat-server-agreement
└─src
    ├─main
    │  ├─java
    │  │  └─org
    │  │      └─example
    │  │          ├─codec
    │  │          │      ObjDecoder.java
    │  │          │      ObjEncoder.java
    │  │          │
    │  │          ├─protocol
    │  │          │      Command.java
    │  │          │      Packet.java
    │  │          │
    │  │          └─util
    │  │                  SerializationUtil.java
    │  │
    │  └─resources
    └─test
        └─java
```
以后每个业务对象都需要继承继承自Packet，实现getCommand方法，获取这个业务对象对应的指令码

之后可以用Maven进行打包，将协议工程的jar包供给服务端与客户端的Netty使用

***
**初步代码**

org/example/codec/ObjDecoder.java
```java
/**
 * 自定义解码器，将接收到的字节转换为指定的传输对象实例
 * @author XiaoRed
 * @date 2023/11/30 15:06
 */
public class ObjDecoder extends ByteToMessageDecoder {

    /**
     * 对接收到的字节进行编码，首先明确统一的通信协议格式：int类型的帧长 + byte类型的指令码 + byte[]业务数据
     * 先根据协议格式，分别获取到这三个部分，然后再转换为对应的业务对象
     */
    @Override
    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) {
        if (in.readableBytes() < 4) { //字节数据长度<4，连一开头的帧长都凑不出来，直接返回，暂不处理
            return;
        }
        in.markReaderIndex(); //记录当前读取位置，之后resetReaderIndex()方法可以返回到该位置
        //1. 获取int类型的帧长，并判断接下来的字节是否包含了这个完整的帧
        int dataLength = in.readInt(); //获取到帧长
        if (in.readableBytes() < dataLength) { //剩余可读部分小于帧长，说明数据包还未接收完整，读取位回退到mark，暂不处理
            in.resetReaderIndex();
            return;
        }
        //2. 获取byte类型的指令码，明确需要将数据转换为什么业务对象
        byte command = in.readByte();
        //3. 获取byte[]的业务数据
        byte[] data = new byte[dataLength - 1]; //指令码占了一位，剔除掉
        in.readBytes(data);
        //4. 将业务数据data转换为指令码对应的业务对象
        out.add(SerializationUtil.deserialize(data, Packet.get(command)));
    }

}
```

org/example/codec/ObjEncoder.java
```java
/**
 * 自定义编码器，将待发送的业务对象(继承于Packet)转换为字节，并封装为统一的通信协议格式
 * @author XiaoRed
 * @date 2023/11/30 15:07
 */
public class ObjEncoder extends MessageToByteEncoder<Packet> {

    @Override
    protected void encode(ChannelHandlerContext ctx, Packet in, ByteBuf out) {
        byte[] data = SerializationUtil.serialize(in); //先将业务对象序列化为字节数组
        //封装待位统一的通信协议格式：int类型的帧长 + byte类型的指令码 + byte[]业务数据
        out.writeInt(data.length + 1); //通信协议包长度：数据长度 + 指令码1位
        out.writeByte(in.getCommand()); //该业务对象对应的指令码
        out.writeBytes(data);
    }

}
```

org/example/protocol/Command.java
```java
/**
 * 定义各个传输对象的指令码
 * @author XiaoRed
 * @date 2023/11/30 15:08
 */
public interface Command {
}
```

org/example/protocol/Packet.java
```java
/**
 * 数据包抽象类，由传输对象继承，主要是为了实现getCommand方法，获取这个传输对象对应的指令码
 * @author XiaoRed
 * @date 2023/11/30 15:09
 */
public abstract class Packet {

    /**
     * key为指令码，value为继承了Packet的传输对象，这个map存储了每个指令码对应的传输对象
     */
    private final static Map<Byte, Class<? extends Packet>> packetType = new ConcurrentHashMap<>();

    /**
     * 将所有<指令码，传输对象>的映射关系提前存到packetType中
     */
    static {

    }

    /**
     * 根据指令码，返回它对应的传输对象
     */
    public static Class<? extends Packet> get(Byte command) {
        return packetType.get(command);
    }

    /**
     * 获取协议指令
     * @return 返回指令值
     */
    public abstract Byte getCommand();

}
```

org/example/util/SerializationUtil.java
```java
/**
 * @author XiaoRed
 * @date 2023/11/30 15:07
 */
public class SerializationUtil {

    private static Map<Class<?>, Schema<?>> cachedSchema = new ConcurrentHashMap<>();

    private static Objenesis objenesis = new ObjenesisStd();

    private SerializationUtil() {

    }

    /**
     * 序列化(对象 -> 字节数组)
     *
     * @param obj 对象
     * @return 字节数组
     */
    public static <T> byte[] serialize(T obj) {
        Class<T> cls = (Class<T>) obj.getClass();
        LinkedBuffer buffer = LinkedBuffer.allocate(LinkedBuffer.DEFAULT_BUFFER_SIZE);
        try {
            Schema<T> schema = getSchema(cls);
            return ProtostuffIOUtil.toByteArray(obj, schema, buffer);
        } catch (Exception e) {
            throw new IllegalStateException(e.getMessage(), e);
        } finally {
            buffer.clear();
        }
    }

    /**
     * 反序列化(字节数组 -> 对象)
     *
     * @param data
     * @param cls
     * @param <T>
     */
    public static <T> T deserialize(byte[] data, Class<T> cls) {
        try {
            T message = objenesis.newInstance(cls);
            Schema<T> schema = getSchema(cls);
            ProtostuffIOUtil.mergeFrom(data, message, schema);
            return message;
        } catch (Exception e) {
            throw new IllegalStateException(e.getMessage(), e);
        }
    }

    private static <T> Schema<T> getSchema(Class<T> cls) {
        Schema<T> schema = (Schema<T>) cachedSchema.get(cls);
        if (schema == null) {
            schema = RuntimeSchema.createFrom(cls);
            cachedSchema.put(cls, schema);
        }
        return schema;
    }

}
```

# 客户端架构设计

**UI层**：引入chat-ui模块对外提供的jar包，并使用内部的接口、事件来操作UI的展现和行为发起。
**业务层**：通信客户端的核心业务主要是负责窗体中用户信息的维护(好友、群组)以及用户和群组之间信息发送和接收操作。也就是在这一层来处理UI的接口与事件。
**协议层**：引入chat-server-agreement模块对外提供的jar包，将定义好的通信协议包集成到Netty客户端
**通信层**：采用Netty框架，轻松实现socket通信

添加chat-client模块，初步构建模块结构如下
```
chat-client
│  .gitignore
│  pom.xml
└─src
    ├─main
    │  ├─java
    │  │  └─org
    │  │      └─example
    │  │          │  Application.java
    │  │          │
    │  │          ├─application
    │  │          ├─domain
    │  │          ├─event
    │  │          │      ChatEvent.java
    │  │          │      LoginEvent.java
    │  │          │
    │  │          ├─infrastructure
    │  │          └─socket
    │  │              │  MyChannelInitializer.java
    │  │              │  MyHandler.java
    │  │              │  NettyClient.java
    │  │              │
    │  │              └─handler
    │  └─resources
    └─test
        └─java
```

***
**具体代码**

引入chat-ui和chat-server-aggrement
```xml
<!--引入UI工程-->
        <dependency>
            <groupId>org.itstack</groupId>
            <artifactId>itstack-naive-chat-ui</artifactId>
            <version>1.0.0-SNAPSHOT</version>
            <scope>compile</scope>
        </dependency>
        <!--引入协议工程-->
        <dependency>
            <groupId>org.example</groupId>
            <artifactId>chat-server-agreement</artifactId>
            <version>1.0-SNAPSHOT</version>
            <scope>compile</scope>
        </dependency>
```

```java
/**
 * @author XiaoRed
 * @date 2023/11/30 18:52
 */
public class NettyClient implements Callable<Channel> {

    private Logger logger = LoggerFactory.getLogger(NettyClient.class);

    private String host = "127.0.0.1";
    private int port = 3000;

    private EventLoopGroup workerGroup = new NioEventLoopGroup();
    private Channel channel;

    @Override
    public Channel call() throws Exception {
        ChannelFuture future = null;
        try{
            Bootstrap bootstrap = new Bootstrap();
            bootstrap
                    .group(workerGroup)
                    .channel(NioSocketChannel.class)
                    .option(ChannelOption.AUTO_READ, true)
                    .handler(new MyChannelInitializer());
            future = bootstrap.connect(host, port).syncUninterruptibly(); //同步阻塞，直到连接建立成功，如果中断，不会抛异常
            this.channel = future.channel();
        }catch (Exception e){
            logger.error("客户端启动失败，", e.getMessage());
        }finally {
            if(future != null && future.isSuccess())
                logger.info("客户端启动成功...");
            else logger.error("客户端启动失败...");
        }
        return channel;
    }

    public void destroy(){
        if(channel == null) return;
        channel.close();
        workerGroup.shutdownGracefully();
    }

    public boolean isActive(){
        return channel.isActive();
    }

    public Channel channel(){
        return channel;
    }
}
```

引入chat-server-agreement模块的jar包后，就可以用里面定义好的ObjDecoder和ObjEncoder了
```java
/**
 * @author XiaoRed
 * @date 2023/11/30 18:53
 */
public class MyChannelInitializer extends ChannelInitializer<SocketChannel> {

    @Override
    protected void initChannel(SocketChannel channel) throws Exception {
        channel.pipeline()
                .addLast(new ObjDecoder()) //对象解码器
                //todo：后续业务功能实现时，不断补全接收数据实现方法
                .addLast(new ObjEncoder()); //对象编码器

    }
}
```

```java
/**
 * 各个业务Handler都会用到以下方法，因此这里做个抽象类，之后的Handler都继承它，直接获取这些通用方法
 * @author XiaoRed
 * @date 2023/11/30 18:53
 */
public abstract class MyHandler<T> extends SimpleChannelInboundHandler<T> {

    @Override
    protected void channelRead0(ChannelHandlerContext ctx, T msg) throws Exception {
        channelRead(ctx.channel(), msg);
    }

    public abstract void channelRead(Channel channel, T msg);

    @Override
    public void channelInactive(ChannelHandlerContext ctx) throws Exception {
        super.channelInactive(ctx);
        System.out.println("断开连接了");
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        System.out.println("关闭" + ctx.channel().id());
    }
}
```


引入chat-ui模块的包后，就可以去实现定义好的ILoginEvent接口。后续编写业务的时候逐一实现
```java
/**
 * @author XiaoRed
 * @date 2023/11/30 18:48
 */
public class LoginEvent implements ILoginEvent {
    @Override
    public void doLoginCheck(String userId, String userPassword) {

    }
}
```

引入chat-ui模块的包后，就可以去实现定义好的IChatEvent接口。后续编写业务的时候逐一实现
```java
/**
 * @author XiaoRed
 * @date 2023/11/30 18:48
 */
public class ChatEvent implements IChatEvent {
    @Override
    public void doQuit() {

    }

    @Override
    public void doSendMsg(String userId, String talkId, Integer talkType, String msg, Integer msgType, Date msgDate) {

    }

    @Override
    public void doEventAddTalkUser(String userId, String userFriendId) {

    }

    @Override
    public void doEventAddTalkGroup(String userId, String groupId) {

    }

    @Override
    public void doEventDelTalkUser(String userId, String talkId) {

    }

    @Override
    public void addFriendLuck(String userId, ListView<Pane> listView) {

    }

    @Override
    public void doFriendLuckSearch(String userId, String text) {

    }

    @Override
    public void doEventAddLuckUser(String userId, String friendId) {

    }
}
```


