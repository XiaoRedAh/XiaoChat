# UI工程

以前我写过一个用swing仿Navicat的小项目，由于是为了应对课程作业，所以没有想太多架构设计上的东西，直接拿来就做了，当时就可以感觉到，桌面开发不同于web，由于控件需要绑定很多事件，常常会将业务代码与页面逻辑都放在一起写，代码即难看，又难维护。

因此在这里，需要将页面搭建独立成一个工程模块模块，让UI与业务进行分离，不要将业务流程代码写到UI窗口里去，而是去定义内部的接口、事件，给业务模块去实现。从这个角度上说，UI模块应该最先编写完，这样，业务模块才能去实现它提供的接口，事件。

UI工程编写完后，用Maven打为jar包，给客户端去引入，使用

# 通信协议设计

## 定义通信协议包

在实际通信过程中，涉及到各种各样的业务对象传输，如果对每种都创建对应的编码&解码器，代码即难看，又难维护，冗余也很多，拓展性也不行

因此需要定义统一的通信协议包如下

|帧长(int)|指令码(Byte)|数据(Byte[])|
|--|--|--|

* **帧长**：用于帧定界，解决粘包，半包等问题
* **指令码**：通过它来判断将数据解析成哪个业务对象，避免大量if语句判断，使得业务更加清晰
* **数据**：业务对象序列化为Byte[]传输

这样设计后，通道中传输的，都是格式一致的ByteBuf协议包，编码&解码流程都得到了统一
* decode解码：接收到Bytebuf数据后，先根据协议包格式，分别获取包的三个部分，然后再转换为对应的业务对象
* encode编码：将待发送的业务对象转换为ByteBuf数据，然后根据这三个部分，封装为统一的通信协议格式

## 初始化协议工程

统一的通信协议是服务端与客户端都要用到的，因此把它单独设计为一个协议工程
在chat-server模块下添加chat-server-agreement子模块，专门负责通信时的协议，初步构建模块结构如下
```
chat-server-agreement
│  pom.xml
└─src
    ├─main
    │  ├─java
    │  │  └─org
    │  │      └─chat
    │  │          └─server
    │  │              ├─codec
    │  │              │      ObjDecoder.java
    │  │              │      ObjEncoder.java
    │  │              │
    │  │              ├─protocol
    │  │              │      Command.java
    │  │              │      Packet.java
    │  │              │
    │  │              └─util
    │  │                      SerializationUtil.java
    │  │
    │  └─resources
    └─test
        └─java
```
以后每个业务对象都需要继承继承自Packet，实现getCommand方法，获取这个业务对象对应的指令码

之后可以用Maven进行打包，将协议工程的jar包供给服务端与客户端的Netty使用

***
**初步代码**

org/chat/server/codec/ObjDecoder.java
```java
/**
 * 自定义解码器，将接收到的字节转换为指定的传输对象实例
 * @author XiaoRed
 * @date 2023/11/30 15:06
 */
public class ObjDecoder extends ByteToMessageDecoder {

    /**
     * 对接收到的字节进行编码，首先明确统一的通信协议格式：int类型的帧长 + byte类型的指令码 + byte[]业务数据
     * 先根据协议格式，分别获取到这三个部分，然后再转换为对应的业务对象
     */
    @Override
    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) {
        if (in.readableBytes() < 4) { //字节数据长度<4，连一开头的帧长都凑不出来，直接返回，暂不处理
            return;
        }
        in.markReaderIndex(); //记录当前读取位置，之后resetReaderIndex()方法可以返回到该位置
        //1. 获取int类型的帧长，并判断接下来的字节是否包含了这个完整的帧
        int dataLength = in.readInt(); //获取到帧长
        if (in.readableBytes() < dataLength) { //剩余可读部分小于帧长，说明数据包还未接收完整，读取位回退到mark，暂不处理
            in.resetReaderIndex();
            return;
        }
        //2. 获取byte类型的指令码，明确需要将数据转换为什么业务对象
        byte command = in.readByte();
        //3. 获取byte[]的业务数据
        byte[] data = new byte[dataLength - 1]; //指令码占了一位，剔除掉
        in.readBytes(data);
        //4. 将业务数据data转换为指令码对应的业务对象
        out.add(SerializationUtil.deserialize(data, Packet.get(command)));
    }

}
```

org/chat/server/codec/ObjEncoder.java
```java
/**
 * 自定义编码器，将待发送的业务对象(继承于Packet)转换为字节，并封装为统一的通信协议格式
 * @author XiaoRed
 * @date 2023/11/30 15:07
 */
public class ObjEncoder extends MessageToByteEncoder<Packet> {

    @Override
    protected void encode(ChannelHandlerContext ctx, Packet in, ByteBuf out) {
        byte[] data = SerializationUtil.serialize(in); //先将业务对象序列化为字节数组
        //封装待位统一的通信协议格式：int类型的帧长 + byte类型的指令码 + byte[]业务数据
        out.writeInt(data.length + 1); //通信协议包长度：数据长度 + 指令码1位
        out.writeByte(in.getCommand()); //该业务对象对应的指令码
        out.writeBytes(data);
    }

}
```

org/chat/server/protocol/Command.java
```java
/**
 * 定义各个传输对象的指令码
 * @author XiaoRed
 * @date 2023/11/30 15:08
 */
public interface Command {
}
```

org/chat/server/protocol/Packet.java
```java
/**
 * 数据包抽象类，由传输对象继承，主要是为了实现getCommand方法，获取这个传输对象对应的指令码
 * @author XiaoRed
 * @date 2023/11/30 15:09
 */
public abstract class Packet {

    /**
     * key为指令码，value为继承了Packet的传输对象，这个map存储了每个指令码对应的传输对象
     */
    private final static Map<Byte, Class<? extends Packet>> packetType = new ConcurrentHashMap<>();

    /**
     * 将所有<指令码，传输对象>的映射关系提前存到packetType中
     */
    static {

    }

    /**
     * 根据指令码，返回它对应的传输对象
     */
    public static Class<? extends Packet> get(Byte command) {
        return packetType.get(command);
    }

    /**
     * 获取协议指令
     * @return 返回指令值
     */
    public abstract Byte getCommand();

}
```

org/chat/server/util/SerializationUtil.java
```java
/**
 * @author XiaoRed
 * @date 2023/11/30 15:07
 */
public class SerializationUtil {

    private static Map<Class<?>, Schema<?>> cachedSchema = new ConcurrentHashMap<>();

    private static Objenesis objenesis = new ObjenesisStd();

    private SerializationUtil() {

    }

    /**
     * 序列化(对象 -> 字节数组)
     *
     * @param obj 对象
     * @return 字节数组
     */
    public static <T> byte[] serialize(T obj) {
        Class<T> cls = (Class<T>) obj.getClass();
        LinkedBuffer buffer = LinkedBuffer.allocate(LinkedBuffer.DEFAULT_BUFFER_SIZE);
        try {
            Schema<T> schema = getSchema(cls);
            return ProtostuffIOUtil.toByteArray(obj, schema, buffer);
        } catch (Exception e) {
            throw new IllegalStateException(e.getMessage(), e);
        } finally {
            buffer.clear();
        }
    }

    /**
     * 反序列化(字节数组 -> 对象)
     *
     * @param data
     * @param cls
     * @param <T>
     */
    public static <T> T deserialize(byte[] data, Class<T> cls) {
        try {
            T message = objenesis.newInstance(cls);
            Schema<T> schema = getSchema(cls);
            ProtostuffIOUtil.mergeFrom(data, message, schema);
            return message;
        } catch (Exception e) {
            throw new IllegalStateException(e.getMessage(), e);
        }
    }

    private static <T> Schema<T> getSchema(Class<T> cls) {
        Schema<T> schema = (Schema<T>) cachedSchema.get(cls);
        if (schema == null) {
            schema = RuntimeSchema.createFrom(cls);
            cachedSchema.put(cls, schema);
        }
        return schema;
    }

}
```

# 服务端架构设计

## 选用DDD架构

在设计架构之前，明确这个系统有什么需求目标：
* 系统在服务端要有web页面进行管理通信用户，以及服务端的控制和监控。
* 数据库的对象类，不要被外部污染，要有隔离性
* 使用Netty进行通信，服务端与客户端都会用到通信过程中的协议定义和解析。因此需要抽离出这一层，对外提供Jar包。
* 接口、业务处理、底层服务、通信交互，要有明确的区分和实现，避免造成混乱难以维护

在这之前，我都是用`MVC三层架构`来开发的，它的分层非常清晰，也不复杂，很好上手。但是随着系统功能不断叠加，MVC架构的代码维护越来越难。
* 就拿vo类来说，每次新添业务后，都想直接复用之前写好的vo，于是直接往里面多丢几个属性，久而久之，这个vo越来越庞大，已经看不清最初的样子了，都不知到它来干嘛的，并且被多个业务代码交叉引用，维护很困难。
* model的功能很单一，只提供get/set，并没有跟随业务走，随着开发代码的不断增多，最后难以维护。

于是在这个项目中，我第一次运用到了`DDD四层架构`来开发【当然，业务没有复杂到那个地步，因此属于轻量级的四层架构】
>**应用层{application}**
>对微服务内的领域服务以及微服务外的应用服务进行组合和编排
>对基础层如文件、缓存等数据直接操作形成应用服务，对外提供粗粒度的服务
>领域事件的发布和订阅。通过事件总线和消息队列实现异步数据传输，实现微服务之间的解耦。
>
>**领域层{domain}**
>领域服务位于领域层，为完成领域中跨实体或值对象的操作转换而封装的服务，领域服务以与实体和值对象相同的方式参与实施过程。
>领域服务对同一个实体的一个或多个方法进行组合和封装，或对多个不同实体的操作进行组合或编排，对外暴露成领域服务。
>领域服务封装了核心的业务逻辑。实体自身的行为在实体类内部实现，向上封装成领域服务暴露。
>为隐藏领域层的业务逻辑实现，所有领域方法和服务等均须通过领域服务对外暴露。
>为实现微服务内聚合之间的解耦，原则上禁止跨聚合的领域服务调用和跨聚合的数据相互关联。
>
>**基础层{infrastructrue}**
基础服务位于基础层。为各层提供资源服务（如数据库、缓存等），实现各层的解耦，降低外部资源变化对业务逻辑的影响。
基础服务主要为仓储服务，通过依赖反转的方式为各层提供基础资源服务，领域服务和应用服务调用仓储服务接口，利用仓储实现持久化数据对象或直接访问基础资源。
>
>**接口层{interfaces}**
>接口服务位于用户接口层，用于处理用户发送的Restful请求和解析用户输入的配置文件等，并将信息传递给应用层。

总的来说，设计出：接口层、业务层、领域层、基础层这四个层级，每一个层级负责不同的内容，并且以领域设计为核心。
这个项目中再额外拓展一个通信层，负责Socket服务端对业务流程的处理和数据转发服务，同时将一些数据，聊天记录等进行落库操作。

## 初始化服务端工程架构

chat-serve模块下添加chat-server-ddd子模块作为服务端
初始化工程结构如下
```
chat-server-ddd
│  pom.xml
└─src
    ├─main
    │  ├─java
    │  │  └─org
    │  │      └─chat
    │  │          └─server
    │  │              │  Application.java
    │  │              │
    │  │              ├─application
    │  │              │      InetService.java
    │  │              │      UserService.java
    │  │              │
    │  │              ├─domain
    │  │              │  ├─inet
    │  │              │  │  ├─model
    │  │              │  │  ├─repository
    │  │              │  │  └─service
    │  │              │  └─user
    │  │              │      ├─model
    │  │              │      │
    │  │              │      ├─repository
    │  │              │      │      IUserRepository.java
    │  │              │      └─service
    │  │              │              UserServiceImpl.java
    │  │              │
    │  │              ├─infrastructure
    │  │              │  ├─common
    │  │              │  │      Constants.java
    │  │              │  │      SocketChannelUtil.java
    │  │              │  │
    │  │              │  ├─dao
    │  │              │  │
    │  │              │  ├─po
    │  │              │  │
    │  │              │  └─repository
    │  │              │          UserRepository.java
    │  │              │
    │  │              ├─interfaces
    │  │              │      InetController.java
    │  │              │
    │  │              └─socket
    │  │                  │  MyChannelInitializer.java
    │  │                  │  MyHandler.java
    │  │                  │  NettyServer.java
    │  │                  │
    │  │                  └─handler
    │  │
    │  └─resources
    │      │  application.yml
    │      │  spring-config.xml
    │      │
    │      ├─mybatis
    │      │  ├─config
    │      │  │
    │      │  └─mapper
    │      │
    │      └─spring
    │              spring-config-service.xml
    │
    └─test
        └─java
```

这里的数据库层、业务层，到最终对外的接口层，所有的对象类都是相互隔离不会造成污染的。
除了添加Socket功能外，没有其他的扩展(如mq，定时任务处理等)，所以比较轻量级的。

整个服务端，划分为用户信息领域和网络通信领域，因此：
* 在application目录下，提供出这两个领域对应对外提供的服务接口：`UserService`和`InetService`
* domain领域层下，提供出这两个领域对应的目录：user和inet

对于domain层里面的每个领域，划分出三个部分
* model层：这个领域在处理业务的时候，涉及到的对象
* reposiroty层：仓储管理model层中的OO对象，在这里只是提供接口，需要在infrastructure层去实现
* service层：通过调用repository层的仓储管理方法，实现该领域对外提供的服务

对于infrastructure层，它就是和数据库打交道了，有以下四个部分：
* common层
* repository层：通过调用dao层方法，实现domain里，各领域的仓储管理
* dao层：直接操作数据库，对po层对象进行crud
* po层：数据表转换为对应的对象

## 部分代码

**具体代码**：主要是socket包下的Netty基本配置，其他业务相关的类都还只是空壳

引入chat-server-aggrement
```xml
<!--引入协议工程-->
<dependency>
    <groupId>org.chat</groupId>
    <artifactId>chat-server-agreement</artifactId>
    <version>1.0-SNAPSHOT</version>
    <scope>compile</scope>
</dependency>
```

org/chat/server/infrastructure/common/SocketChannelUtil.java
这个channel管理类很关键，用于存储并管理“用户-channel“对应关系，“群组-channel组”对应关系，后续服务端处理单聊，群聊时需要用到
```java
/**
 * 管理channel工具类
 * @author XiaoRed
 * @date 2023/12/1 22:38
 */
public class SocketChannelUtil {
    /**
     * 存储channel和用户的对应关系，以用户id为key，channel为value
     */
    private static final Map<String, Channel> userChannel = new ConcurrentHashMap<>();
    /**
     * 存储channelId和用户的对应关系，以channelId为key，用户id为值
     */
    private static final Map<String, String> userChannelId = new ConcurrentHashMap<>();
    /**
     * 存储群组及其现有channel的对应关系，以群号为key，channel组为值
     */
    private static final Map<String, ChannelGroup> channelGroupMap = new ConcurrentHashMap<>();

    //<==============================单聊相关操作=====================================>
    /**
     * 新的客户端连接建立时，将用户以及channel的对应关系记录下来，方便后续使用
     */
    public static void addChannel(String userId, Channel channel) {
        userChannel.put(userId, channel);
        userChannelId.put(channel.id().toString(), userId);
    }

    /**
     * 根据channelId，将用户-channel的对应记录删除
     */
    public static void removeChannel(String channelId){
        String userId = userChannelId.get(channelId);
        if (null == userId) return;
        userChannel.remove(userId);
    }

    public static void removeUserChannelByUserId(String userId){
        userChannel.remove(userId);
    }

    public static Channel getChannelByUserId(String userId) {
        return userChannel.get(userId);
    }

    //<==============================群组相关操作=====================================>
    /**
     * 新成员加入群组时，往群组中添加新的成员通信管道
     * @param talkId  对话框ID[群号]
     * @param userChannel 群员通信管道
     */
    public synchronized static void addChannelGroup(String talkId, Channel userChannel) {
        ChannelGroup channelGroup = channelGroupMap.get(talkId);
        if (null == channelGroup) {
            channelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);
            channelGroupMap.put(talkId, channelGroup);
        }
        channelGroup.add(userChannel);
    }

    /**
     * 群组中有用户离开，则将他的通信信道从信道组中移除
     * @param talkId  对话框ID[群号]
     * @param userChannel 群员通信管道
     */
    public synchronized static void removeChannelGroup(String talkId, Channel userChannel){
        ChannelGroup channelGroup = channelGroupMap.get(talkId);
        if (null == channelGroup) return;
        channelGroup.remove(userChannel);
    }

    /**
     * 移除channel所在的群组
     */
    public static void removeChannelGroupByChannel(Channel channel){
        for (ChannelGroup next : channelGroupMap.values()) {
            next.remove(channel);
        }
    }

    /**
     * 根据群号，获取群组通信管道
     * @param talkId 对话框ID[群号]
     * @return 群组
     */
    public static ChannelGroup getChannelGroup(String talkId) {
        return channelGroupMap.get(talkId);
    }

}
```

org/chat/server/socket/NettyServer.java
实现Callable接口，在启动类中结合线程池，多线程异步启动Netty服务端
```java
/**
 * Netty服务实现Callable的call方法，在call方法中进行Netty服务端的启动
 * 实现Callable的类，可以当作线程任务交给线程池执行
 * 线程池会分配给这个类一个线程，去执行call方法
 * 这样，Netty服务端的启动就是一个交给其他线程执行的异步操作，不会影响(阻塞)主线程，主线程只需要等它执行完后，拿结果即可
 * @author XiaoRed
 * @date 2023/12/1 15:26
 */
@Service("nettyServer")
public class NettyServer implements Callable<Channel> {

    private final Logger logger = LoggerFactory.getLogger(NettyServer.class);
    @Resource
    private UserService userService;
    private final EventLoopGroup bossGroup = new NioEventLoopGroup(2);
    private final EventLoopGroup workerGroup = new NioEventLoopGroup();
    private Channel channel;
    @Override
    public Channel call() throws Exception {
        ChannelFuture future = null;
        try{
            ServerBootstrap bootstrap = new ServerBootstrap();
            bootstrap
                    .group(bossGroup, workerGroup)
                    .channel(NioServerSocketChannel.class)
                    .option(ChannelOption.SO_BACKLOG, 128)
                    .childHandler(new MyChannelInitializer(userService));
            future = bootstrap.bind(new InetSocketAddress(3000)).syncUninterruptibly();
            this.channel = future.channel();
        }catch (Exception e){
            logger.error("服务端启动失败：{}", e.getMessage());
        }finally {
            if(future != null && future.isSuccess())
                logger.info("服务端启动成功 {}", channel.localAddress());
            else logger.error("服务端启动失败...");
        }
        return this.channel;
    }

    public void destroy(){
        if(channel == null) return;
        channel.close();
        bossGroup.shutdownGracefully();
        workerGroup.shutdownGracefully();
    }

    public Channel channel() {return channel;}
}
```

org/chat/server/socket/MyChannelInitializer.java
引入chat-server-agreement模块的jar包后，就可以用里面定义好的ObjDecoder和ObjEncoder了
```java
/**
 * @author XiaoRed
 * @date 2023/12/1 15:33
 */
public class MyChannelInitializer extends ChannelInitializer<SocketChannel> {

    private final UserService userService;

    public MyChannelInitializer(UserService userService){
        this.userService = userService;
    }
    @Override
    protected void initChannel(SocketChannel channel) throws Exception {
        channel.pipeline()
                .addLast(new ObjDecoder()) //对象解码器
                //todo：后续业务功能实现时，不断补全接收数据实现方法
                .addLast(new ObjEncoder()); //对象编码器
    }
}
```

org/chat/server/socket/MyHandler.java
```java
/**
 * 各个业务Handler都会用到以下方法，因此这里做个抽象类，之后的Handler都继承它，直接获取这些通用方法
 * @author XiaoRed
 * @date 2023/12/1 15:32
 */
public abstract class MyHandler<T> extends SimpleChannelInboundHandler<T> {

    protected Logger logger = LoggerFactory.getLogger(MyHandler.class);

    protected UserService userService;

    public MyHandler(UserService userService) {this.userService = userService;}

    public abstract void channelRead(Channel channel, T msg);

    @Override
    protected void channelRead0(ChannelHandlerContext ctx, T msg) throws Exception {
        channelRead(ctx.channel(), msg);
    }

    @Override
    public void channelActive(ChannelHandlerContext ctx) throws Exception {
        super.channelActive(ctx);
        logger.info("有新的客户端连接到服务端：" + ctx.channel());
    }

    @Override
    public void channelInactive(ChannelHandlerContext ctx) throws Exception {
        super.channelInactive(ctx);
        SocketChannelUtil.removeChannel(ctx.channel().id().toString());
        SocketChannelUtil.removeChannelGroupByChannel(ctx.channel());
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        logger.error("与客户端" + ctx.channel().remoteAddress() + "在通讯中发生异常：" + cause.getMessage() + " 打印异常路径如下：");
        cause.printStackTrace();
        SocketChannelUtil.removeChannel(ctx.channel().id().toString());
        SocketChannelUtil.removeChannelGroupByChannel(ctx.channel());
    }
}
```

启动类 org/chat/server/Application.java
启动类采用SpringBoot整合Netty，相关配置文件就不展示了
```java
/**
 * @author XiaoRed
 * @date 2023/12/1 15:24
 */
@SpringBootApplication
@Configuration
@ImportResource(locations = {"classpath:spring-config.xml"})
public class Application extends SpringBootServletInitializer implements CommandLineRunner {

    private final Logger logger = LoggerFactory.getLogger(Application.class);

    @Resource
    private NettyServer nettyServer;

    /**
     * 启动SpringBoot
     */
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }

    /**
     * 直接用SpringBoot的run方法，默认读取application.yml配置文件
     * 如果需要读取其他配置文件，就要用到这个configure方法，这里额外读取@ImportResource指定的spring-config.xml配置文件
     * spring-config.xml配置异步线程池
     */
    @Override
    protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) {
        return builder.sources(Application.class);
    }

    /**
     * 应用初始化后，调用这个run方法，利用多线程启动Netty服务端
     */
    @Override
    public void run(String... args) throws Exception {
        logger.info("Netty服务端正在启动【port：3000】...");
        //Netty服务端实现了Callable接口，可以把它作为线程任务交给线程池去执行call方法，这样一来，Netty服务端的启动就是异步操作，主线程继续做其它事，等异步任务做完后，主线程再来拿执行结果
        Future<Channel> future = Executors.newFixedThreadPool(2).submit(nettyServer);
        Channel channel = future.get();
        if (null == channel) throw new RuntimeException("Netty服务端启动失败：channel is null");
        //启动过程中，不断检查channel状态，每0.5s检查一次，直到channel处于channel状态为止
        while (!channel.isActive()) {
            logger.info("Netty服务正在进行连接服务 ...");
            Thread.sleep(500);
        }
        logger.info("服务端连接服务完成 {}", channel.localAddress());
    }

}
```

# 客户端架构设计

**UI层**：引入chat-ui模块对外提供的jar包，并使用内部的接口、事件来操作UI的展现和行为发起。
**业务层**：通信客户端的核心业务主要是负责窗体中用户信息的维护(好友、群组)以及用户和群组之间信息发送和接收操作。也就是在这一层来处理UI的接口与事件。
**协议层**：引入chat-server-agreement模块对外提供的jar包，将定义好的通信协议包集成到Netty客户端
**通信层**：采用Netty框架，轻松实现socket通信

添加chat-client模块，初步构建模块结构如下
```
chat-client
│  .gitignore
│  pom.xml
└─src
    ├─main
    │  ├─java
    │  │  └─org
    │  │      └─chat
    │  │          └─client
    │  │              │  Application.java
    │  │              │
    │  │              ├─application
    │  │              ├─domain
    │  │              ├─event
    │  │              │      ChatEvent.java
    │  │              │      LoginEvent.java
    │  │              │
    │  │              ├─infrastructure
    │  │              └─socket
    │  │                  │  MyChannelInitializer.java
    │  │                  │  MyHandler.java
    │  │                  │  NettyClient.java
    │  │                  │
    │  │                  └─handler
    │  └─resources
    └─test
        └─java
```

***
**具体代码**

引入chat-ui和chat-server-aggrement
```xml
<!--引入UI工程-->
<dependency>
    <groupId>org.chat</groupId>
    <artifactId>chat-ui</artifactId>
    <version>1.0.0-SNAPSHOT</version>
    <scope>compile</scope>
</dependency>
<!--引入协议工程-->
<dependency>
    <groupId>org.chat</groupId>
    <artifactId>chat-server-agreement</artifactId>
    <version>1.0-SNAPSHOT</version>
    <scope>compile</scope>
</dependency>
```

org/chat/client/socket/NettyClient.java
实现Callable接口，在启动类中结合线程池，多线程异步启动Netty客户端
```java
/**
 * Netty客户端实现Callable的call方法，在call方法中进行Netty客户端的启动，连接
 * 实现Callable的类，可以当作线程任务交给线程池执行
 * 线程池会分配给这个类一个线程，去执行call方法
 * 这样，Netty客户端的启动就是一个交给其他线程执行的异步操作，不会影响(阻塞)主线程，主线程只需要等它执行完后，拿结果即可
 * @author XiaoRed
 * @date 2023/11/30 18:52
 */
public class NettyClient implements Callable<Channel> {

    private final Logger logger = LoggerFactory.getLogger(NettyClient.class);

    private final String host = "127.0.0.1";
    private final int port = 3000;

    private final EventLoopGroup workerGroup = new NioEventLoopGroup();
    private Channel channel;

    private final UIService uiService;

    public NettyClient(UIService uiService) {
        this.uiService = uiService;
    }

    @Override
    public Channel call() throws Exception {
        ChannelFuture future = null;
        try{
            Bootstrap bootstrap = new Bootstrap();
            bootstrap
                    .group(workerGroup)
                    .channel(NioSocketChannel.class)
                    .option(ChannelOption.AUTO_READ, true)
                    .handler(new MyChannelInitializer(uiService));
            future = bootstrap.connect(host, port).syncUninterruptibly(); //同步阻塞，直到连接建立成功，如果中断，不会抛异常
            this.channel = future.channel();
            // 其他地方要用到这个通信管道，因此存入BeanUtil中，哪里要用到，就从BeanUtil里拿出来用
            BeanUtil.addBean("Channel", this.channel);
        }catch (Exception e){
            logger.error("客户端启动失败 {}", e.getMessage());
        }finally {
            if(future != null && future.isSuccess())
                logger.info("客户端启动成功...");
            else logger.error("客户端启动失败...");
        }
        return channel;
    }

    public void destroy(){
        if(channel == null) return;
        channel.close();
        workerGroup.shutdownGracefully();
    }

    public boolean isActive(){
        return channel.isActive();
    }

    public Channel channel(){
        return channel;
    }
}
```

org/chat/client/socket/MyChannelInitializer.java
引入chat-server-agreement模块的jar包后，就可以用里面定义好的ObjDecoder和ObjEncoder了
```java
/**
 * @author XiaoRed
 * @date 2023/11/30 18:53
 */
public class MyChannelInitializer extends ChannelInitializer<SocketChannel> {

    @Override
    protected void initChannel(SocketChannel channel) throws Exception {
        channel.pipeline()
                .addLast(new ObjDecoder()) //对象解码器
                //todo：后续业务功能实现时，不断补全接收数据实现方法
                .addLast(new ObjEncoder()); //对象编码器

    }
}
```

org/chat/client/socket/MyHandler.java
```java
/**
 * 各个业务Handler都会用到以下方法，因此这里做个抽象类，之后的Handler都继承它，直接获取这些通用方法
 * @author XiaoRed
 * @date 2023/11/30 18:53
 */
public abstract class MyHandler<T> extends SimpleChannelInboundHandler<T> {

    @Override
    protected void channelRead0(ChannelHandlerContext ctx, T msg) throws Exception {
        channelRead(ctx.channel(), msg);
    }

    public abstract void channelRead(Channel channel, T msg);

    @Override
    public void channelInactive(ChannelHandlerContext ctx) throws Exception {
        super.channelInactive(ctx);
        logger.info("与服务端的连接断开了...");
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        logger.error("与服务端通讯中发生异常：" + cause.getMessage() + "打印异常路径如下：");
        cause.printStackTrace();
        logger.info("关闭" + ctx.channel().id());
    }
}
```
启动类 org/chat/client/Application.java
```java
/**
 * @author XiaoRed
 * @date 2023/11/30 18:48
 */
public class Application extends javafx.application.Application {

    private final Logger logger = LoggerFactory.getLogger(Application.class);

    //默认线程池
    private static final ExecutorService executorService = Executors.newFixedThreadPool(2);
    private final ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(1);

    @Override
    public void start(Stage primaryStage) throws Exception {
        //1. 初始化登录，聊天method，展示登录界面
        IChatMethod chat = new ChatController(new ChatEvent());
        ILoginMethod login = new LoginController(new LoginEvent(), chat);
        login.doShow();

        //2. 初始化UIService，将chat和login装入
        UIService uiService = new UIService();
        uiService.setChat(chat);
        uiService.setLogin(login);

        //3. 多线程启动Netty客户端
        logger.info("Netty客户端连接服务开始 inetHost：{} inetPort：{}", "127.0.0.1", 3000);
        NettyClient nettyClient = new NettyClient(uiService);
        //Netty客户端实现了Callable接口，可以把它作为线程任务交给线程池去执行call方法，这样一来，Netty客户端的启动就是异步操作，主线程继续做其它事，等异步任务做完后，主线程再来拿执行结果
        Future<Channel> future = executorService.submit(nettyClient);
        Channel channel = future.get();
        if (null == channel) throw new RuntimeException("Netty客户端启动失败：channel is null");

        //4. 每0.5秒检测一次channel是否为active状态，直到channel变为active状态
        while (!nettyClient.isActive()) {
            logger.info("Netty客户端正在进行连接服务...");
            Thread.sleep(500);
        }
        logger.info("Netty客户端连接服务完成 {}", channel.localAddress());

    }

    public static void main(String[] args) {
        launch(args);
    }
}
```

org/chat/client/event/LoginEvent.java
引入chat-ui模块的包后，就可以去实现定义好的ILoginEvent接口。后续编写业务的时候逐一实现
```java
/**
 * @author XiaoRed
 * @date 2023/11/30 18:48
 */
public class LoginEvent implements ILoginEvent {
    @Override
    public void doLoginCheck(String userId, String userPassword) {

    }
}
```

org/chat/client/event/ChatEvent.java
引入chat-ui模块的包后，就可以去实现定义好的IChatEvent接口。后续编写业务的时候逐一实现
```java
/**
 * @author XiaoRed
 * @date 2023/11/30 18:48
 */
public class ChatEvent implements IChatEvent {
    @Override
    public void doQuit() {

    }

    @Override
    public void doSendMsg(String userId, String talkId, Integer talkType, String msg, Integer msgType, Date msgDate) {

    }

    @Override
    public void doEventAddTalkUser(String userId, String userFriendId) {

    }

    @Override
    public void doEventAddTalkGroup(String userId, String groupId) {

    }

    @Override
    public void doEventDelTalkUser(String userId, String talkId) {

    }

    @Override
    public void addFriendLuck(String userId, ListView<Pane> listView) {

    }

    @Override
    public void doFriendLuckSearch(String userId, String text) {

    }

    @Override
    public void doEventAddLuckUser(String userId, String friendId) {

    }
}
```

# 回顾-多线程启动Netty

在前面初始化服务端，客户端工程中，NettyServer和NettyClient都实现了`Callable<Channel>`类，它们的启动代码都写在这个`call`方法中

实现Callable的类，可以作为线程任务交给线程池去调用call方法。这样一来，系统在启动Netty服务端和Netty客户端的时候，都是使用多线程的方式，主线程不会受到影响(阻塞)，只需要线程任务完成后，再来拿结果就行（异步）

选择实现Callable接口，与选择实现Runable接口相比，有以下两优势：
https://zhuanlan.zhihu.com/p/116116346
* 线程任务call方法可以有返回值
* call方法可以抛异常
* 运行Callable任务可以拿到一个Future对象，表示异步计算的结果

多线程的方式启动Netty，方便控制，性能也有优化

# 库表设计

基础表：用户表，群组表
关联表：用户-好友表，用户-群组表
行为表：聊天记录表，对话框表

**用户表**
```sql
DROP TABLE user;
CREATE TABLE user ( 
id bigint NOT NULL AUTO_INCREMENT COMMENT '自增ID',
userId varchar(9) COMMENT '用户ID', 
userNickName varchar(32) COMMENT '用户昵称', 
userHead varchar(16) COMMENT '用户头像',
userPassword varchar(64) COMMENT '用户密码', 
createTime datetime COMMENT '创建时间', 
updateTime datetime COMMENT '更新时间', 
PRIMARY KEY (id) ) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

**群组表**
```sql
DROP TABLE groups;
CREATE TABLE groups (
id bigint NOT NULL AUTO_INCREMENT COMMENT '自增ID',
groupId varchar(9) COMMENT '群组ID',
groupName varchar(16) COMMENT '群组名称', 
groupHead varchar(16) COMMENT '群组头像', 
createTime datetime COMMENT '创建时间', 
updateTime datetime COMMENT '更新时间', 
PRIMARY KEY (id), 
CONSTRAINT idx_groupId UNIQUE (groupId) ) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

**用户-好友表**
目前的表结构字段比较简单，还有很多可以拓展的地方【好友的添加方式(扫码、手机号搜索、好友分享)、添加地点、添加时间，是否被删除等等】
用户的好友关系是双向的：你是我的好友，我也是你的好友。
```sql
DROP TABLE user_friend;
CREATE TABLE user_friend ( 
id bigint NOT NULL AUTO_INCREMENT COMMENT '自增ID', 
userId bigint COMMENT '用户ID', 
userFriendId bigint COMMENT '好友用户ID', 
createTime datetime COMMENT '创建时间',
updateTime datetime COMMENT '更新时间', 
PRIMARY KEY (id), 
CONSTRAINT uuid_idx UNIQUE (userId, userFriendId) ) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

**用户-群组表**
主要维护用户都参与到哪些群组里。同样的，目前的表结构字段比较简单，后续有特别需求可以往里面拓展
```sql
DROP TABLE user_group;
CREATE TABLE user_group ( 
id bigint NOT NULL AUTO_INCREMENT COMMENT '自增ID',
userId varchar(9) COMMENT '用户ID', 
groupId varchar(9) COMMENT '群组ID', 
createTime datetime COMMENT '创建时间', 
updateTime datetime COMMENT '更新时间', 
PRIMARY KEY (id), 
CONSTRAINT idx_uuid UNIQUE (userId, groupId) ) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

**聊天记录表**
主要记录每个用户与好友或者群组的聊天消息信息，每一个聊天消息发送到服务端后都会**采用异步的方式进行落库记录**，以减少服务端耗时。
随着业务的拓展，可以进行对应的扩展
```sql
DROP TABLE chat_record;
CREATE TABLE chat_record ( 
id bigint NOT NULL AUTO_INCREMENT COMMENT '自增ID', 
userId varchar(9) COMMENT '自己ID', 
friendId varchar(9) COMMENT '好友ID',
msgContent varchar(512) COMMENT '消息内容', 
msgDate datetime COMMENT '消息时间', 
createTime datetime COMMENT '创建时间', 
updateTime datetime COMMENT '更新时间', 
talkType int(4), COMMENT '对话类型；0好友，1群组',
msgType int(4) DEFAULT '0', 
PRIMARY KEY (id) ) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

**对话框表**
也就是ui界面左侧的通信记录载体对话框
```sql
DROP TABLE talk_box;
CREATE TABLE talk_box (
id bigint NOT NULL AUTO_INCREMENT COMMENT '自增ID', 
userId varchar(9) COMMENT '用户ID', 
talkId varchar(9) COMMENT '对话框ID(好友ID、群组ID)',
talkType int(4) COMMENT '对话框类型；0好友、1群组', 
createTime datetime COMMENT '创建时间', 
updateTime datetime COMMENT '更新时间', 
PRIMARY KEY (id),
CONSTRAINT idx_talkId_userId UNIQUE (userId, talkId) ) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

***
库表设计完后，使用Mybatis框架将库表结构初始化到代码中，为了以后的拓展性，本项目采用xml文件手写sql语句。

数据库相关的初始化工作就是添加以下三个部分：
* 数据库PO对象类
* 数据库操作方法DAO
* Mapper文件配置

chat-server-ddd的infrastructure目录
```
infrastructure
├─common
├─dao
│      IChatRecordDao.java
│      IGroupsDao.java
│      ITalkBoxDao.java
│      IUserDao.java
│      IUserFriendDao.java
│      IUserGroupDao.java
│
├─po
│      ChatRecord.java
│      Groups.java
│      TalkBox.java
│      User.java
│      UserFriend.java
│      UserGroup.java
└─repository
```

chat-server-ddd的resources目录
```
resources
└─mybatis
    ├─config
    └─mapper
            ChatRecord_Mapper.xml
            Groups_Mapper.xml
            TalkBox_Mapper.xml
            UserFriend_Mapper.xml
            UserGroup_Mapper.xml
            User_Mapper.xml
```

# 后续开发流程

通过前面项目模块的划分，架构的初始化搭建后，项目基本框架已经有了，而且后续的开发流程也变得清晰简单，且固定下来：
* 协议包定义
* UI事件实现
* 服务端处理请求
* 客户端处理响应



